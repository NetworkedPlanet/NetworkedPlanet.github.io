<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TMCore Engine API Guide</title><link rel="stylesheet" href="../doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="pageheader"><table class="logo" width="100%" border="0" cellpadding="0" cellspacing="0"><tr><td><span class="networked">Networked</span><span class="planet">Planet</span></td><td align="right"><span class="title">TMCore Engine API Guide</span></td></tr></table></div><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>TMCore Engine API Guide</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d0e6">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e26">Acknowledgements</a></span></dt><dt><span class="section"><a href="#d0e31">Conventions Used</a></span></dt><dt><span class="section"><a href="#d0e71">Summary Of Changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e76">Changes In TMCore07 SP3</a></span></dt><dt><span class="section"><a href="#d0e97">Changes In TMCore07</a></span></dt><dt><span class="section"><a href="#d0e134">Changes Prior To TMCore07</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e157">2. Before You Get Started</a></span></dt><dt><span class="chapter"><a href="#d0e172">3. TMCore API Programming Kickstart</a></span></dt><dd><dl><dt><span class="section"><a href="#compiling-examples">Compiling and Running the Examples</a></span></dt><dt><span class="section"><a href="#d0e201">APIExample1 : Creating a topic map with topics and
      associations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e447">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e458">APIExample2 : Working With Indexes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e557">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e562">APIExample3 : Reading And Writing XTM with IXTMProcessor</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e668">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e675">APIExample4: Using TMRQL</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e771">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e780">APIExample5: Using The ApplicationOntology Cache</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e819">Running The Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e826">4. TMCore API Overview</a></span></dt><dt><span class="chapter"><a href="#core-api">5. Core API</a></span></dt><dd><dl><dt><span class="section"><a href="#TopicMapSystem_TopicMapSystemFactory">ITopicMapSystem and TopicMapSystemFactory</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1044">Other ITopicMapSystem Methods</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1085">ITopicMapObject And Its Derived Interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1093">Containment and Object Creation and Removal</a></span></dt><dt><span class="section"><a href="#d0e1214">ITopicMapObject</a></span></dt><dt><span class="section"><a href="#d0e1268">ITopicMap</a></span></dt><dt><span class="section"><a href="#d0e1328">Mapping TMCore Interfaces And Properties to XTM Elements And
        Attribute</a></span></dt><dt><span class="section"><a href="#d0e1497">Concurrent Modification</a></span></dt><dt><span class="section"><a href="#d0e1551">Topic Merging</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#indexes">6. Indexes</a></span></dt><dd><dl><dt><span class="section"><a href="#IndexAPI">The IIndex Interface</a></span></dt><dt><span class="section"><a href="#basicindexes">The Core Indexes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tmsyntax">7. Importing and Exporting XTM Files</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1782">ImportXTM()</a></span></dt><dt><span class="section"><a href="#d0e1931">ExportXTM()</a></span></dt></dl></dd><dt><span class="chapter"><a href="#utilities">8. TMCore System Utilities</a></span></dt><dd><dl><dt><span class="section"><a href="#change-notification">Change Notification</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2030">Database Considerations</a></span></dt></dl></dd><dt><span class="section"><a href="#ApplicationOntology">The ApplicationOntology Object</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2086">How the <code class="classname">ApplicationOntology</code> Works</a></span></dt><dt><span class="section"><a href="#d0e2113">Configuring The Application Ontology</a></span></dt><dt><span class="section"><a href="#d0e2225">Using the <code class="classname">ApplicationOntology</code></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2285">Creating and Accessing Topic Hierarchies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2296">Creating a Hierarchy</a></span></dt><dt><span class="section"><a href="#d0e2493">Using The HierarchyManager API</a></span></dt><dt><span class="section"><a href="#d0e2575">Hierarchy Manager Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#querying">9. Querying</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2605">Using TMCore Public Views And Functions</a></span></dt><dt><span class="section"><a href="#executing.queries">Executing Queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2793">Other Options For Working With Results Sets</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2847">Querying Efficiently</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2862">Limiting Data Read In A Results Row</a></span></dt><dt><span class="section"><a href="#d0e2876">Performing Query Analysis</a></span></dt><dt><span class="section"><a href="#d0e2896">Use The ApplicationOntology Cache Object</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#transactional.api">10. Fast Topic Map Updates with the TransactionalPersistenceManager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2913">Introduction</a></span></dt><dt><span class="section"><a href="#d0e2922">Transactional API Usage</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2925">Basic Usage Pattern</a></span></dt><dt><span class="section"><a href="#d0e2953">Using the Tranactional API and Query API</a></span></dt><dt><span class="section"><a href="#d0e2958">Updating Topic Characteristics</a></span></dt><dt><span class="section"><a href="#d0e2963">Wildcards in Transaction Operations</a></span></dt><dt><span class="section"><a href="#d0e2970">Cautions On Use</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2985">Sample code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#npcl-overview">11. The NetworkedPlanet Constraint Language (NPCL)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2999">Key Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3004">Types</a></span></dt><dt><span class="section"><a href="#d0e3097">Constraints</a></span></dt><dt><span class="section"><a href="#d0e3147">Superclass-Subclass Inheritance</a></span></dt><dt><span class="section"><a href="#d0e3177">Scoping Topics</a></span></dt></dl></dd><dt><span class="section"><a href="#npcl-schema">NPCL XML Schema</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3185">Overview</a></span></dt><dt><span class="section"><a href="#d0e3193">Namespace</a></span></dt><dt><span class="section"><a href="#d0e3198"><code class="sgmltag-element">schema Element</code></a></span></dt><dt><span class="section"><a href="#d0e3255"><code class="sgmltag-element">abstractType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3298"><code class="sgmltag-element">topicType</code></a></span></dt><dt><span class="section"><a href="#d0e3393"><code class="sgmltag-element">occurrenceType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3466"><code class="sgmltag-element">associationType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3544"><code class="sgmltag-element">roleType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3593"><code class="sgmltag-element">scopingTopic</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3624"><code class="sgmltag-element">subclasses</code> Element</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3651">NPCL Topic Map Ontology</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3659">NPCL Meta Types</a></span></dt><dt><span class="section"><a href="#d0e3811">Constraint Topics</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#npcl-api">12. The NPCL Constraints API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4137">Overview</a></span></dt><dt><span class="section"><a href="#d0e4142">Representation Of The NPCL Model</a></span></dt><dt><span class="section"><a href="#d0e4241">API Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4246">Creating A Schema</a></span></dt><dt><span class="section"><a href="#d0e4275">Retrieving Information From A Schema</a></span></dt><dt><span class="section"><a href="#npcl-api-saving">Saving A Schema</a></span></dt><dt><span class="section"><a href="#d0e4377">Loading A Schema</a></span></dt><dt><span class="section"><a href="#d0e4389">A Dynamic Schema Interface</a></span></dt><dt><span class="section"><a href="#d0e4421">Generating A Schema From A Topic Map</a></span></dt><dt><span class="section"><a href="#d0e4472">Example Code</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e4549">13. Duplicate Removal</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4552">Introduction</a></span></dt><dt><span class="section"><a href="#d0e4559">What Is Duplicate Information?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4564">Duplicate Information on a Topic</a></span></dt><dt><span class="section"><a href="#d0e4587">Duplicate Information on an Association</a></span></dt><dt><span class="section"><a href="#d0e4596">Duplicate Associations</a></span></dt></dl></dd><dt><span class="section"><a href="#duplicate.removal">Duplicate Removal Procedures</a></span></dt></dl></dd><dt><span class="chapter"><a href="#logging">14. Logging</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>8.1. <a href="#d0e2420">Defining A Hierarchy Model</a></dt><dt>12.1. <a href="#d0e4230">NPCL Containment Hierarchy</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>5.1. <a href="#d0e962">ITopicMapSystem Configuration Properties</a></dt><dt>6.1. <a href="#d0e1615">TMAPI Core Indexes</a></dt><dt>8.1. <a href="#hierarchy-psis">Topic PSIs for Topic Hierarchies</a></dt><dt>11.1. <a href="#d0e3664">NPCL Meta Types</a></dt><dt>11.2. <a href="#d0e3751">Occurrence Type Value Facets</a></dt><dt>11.3. <a href="#d0e3816">NPCL Constraint Topic Types</a></dt><dt>11.4. <a href="#d0e3865">Minimum And Maximum Cardinality Facet Meanings</a></dt><dt>11.5. <a href="#d0e3911">Associations Required To Specify An Occurrence
          Constraint</a></dt><dt>11.6. <a href="#d0e3980">Associations Used To Specify A Role Player Constraint</a></dt><dt>11.7. <a href="#d0e4070">Associations Required To Specify An Association Role
          Constraint</a></dt><dt>12.1. <a href="#d0e4147">Interfaces Representing the NPCL Model</a></dt><dt>12.2. <a href="#d0e4480">NPCL API Examples</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#simple-create">Creating a Topic Map</a></dt><dt>3.2. <a href="#d0e239">Topic Map Application Configuration File</a></dt><dt>3.3. <a href="#d0e248">Safely Creating a Topic Map</a></dt><dt>3.4. <a href="#d0e267">Creating and Populating Topics</a></dt><dt>3.5. <a href="#d0e356">Creating and Populating Associations</a></dt><dt>3.6. <a href="#d0e393">Looping over Topics and Associations</a></dt><dt>3.7. <a href="#d0e415">Accessing Topic Data</a></dt><dt>3.8. <a href="#d0e474">The Main Program Flow</a></dt><dt>3.9. <a href="#d0e500">Creating the Topic Map Ontology</a></dt><dt>3.10. <a href="#d0e507">Using Indexes</a></dt><dt>3.11. <a href="#d0e541">Listing All Topic Types</a></dt><dt>3.12. <a href="#d0e574">Reading An XTM File</a></dt><dt>3.13. <a href="#d0e633">Writing An XTM File</a></dt><dt>5.1. <a href="#d0e1028">A simple .config file for a TMCore Application</a></dt><dt>7.1. <a href="#d0e1920">Examples of Importing Into TMCore</a></dt><dt>9.1. <a href="#d0e2774">Using ITMCoreDataReader</a></dt><dt>9.2. <a href="#d0e2783">Using ExecuteQuery(string, IList)</a></dt><dt>9.3. <a href="#d0e2788">Using ExecuteQuery(string, Hashtable)</a></dt><dt>11.1. <a href="#d0e3725">XTM For A Topic Type</a></dt><dt>11.2. <a href="#d0e3741">An Abstract Topic Type</a></dt><dt>11.3. <a href="#d0e3792">Occurrence Type Value Facets In XTM</a></dt><dt>11.4. <a href="#d0e3804">Topic Type Scoping Facets In XTM</a></dt><dt>11.5. <a href="#d0e3901">The Arc Label Facet Expressed in XTM Syntax</a></dt><dt>11.6. <a href="#d0e3968">Example Occurrence Constraint</a></dt><dt>11.7. <a href="#d0e4058">A Role Player Constraint Specified In XTM</a></dt><dt>11.8. <a href="#d0e4127">An Association Role Constraint in XTM</a></dt><dt>12.1. <a href="#d0e4270">C# Code To Create An NPCL Schema</a></dt><dt>12.2. <a href="#d0e4337">Writing a Schema as XML</a></dt><dt>12.3. <a href="#d0e4372">Writing A Schema Into A Topic Map</a></dt><dt>12.4. <a href="#d0e4384">Reading A Schema</a></dt><dt>12.5. <a href="#d0e4458">Generating An NPCL Schema File From A Topic Map</a></dt><dt>12.6. <a href="#d0e4465">Generating And Adding Schema Information To A Topic Map</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e6"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e26">Acknowledgements</a></span></dt><dt><span class="section"><a href="#d0e31">Conventions Used</a></span></dt><dt><span class="section"><a href="#d0e71">Summary Of Changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e76">Changes In TMCore07 SP3</a></span></dt><dt><span class="section"><a href="#d0e97">Changes In TMCore07</a></span></dt><dt><span class="section"><a href="#d0e134">Changes Prior To TMCore07</a></span></dt></dl></dd></dl></div><p>TMCore provides a complete Application Programming Interface (API)
    for accessing and manipulating topic map data. The implementation of this
    API provided by TMCore is written entirely in C# as managed code. This
    allows the API to be accessed from any programming lanuage supported by
    the Microsoft Common Language Runtime (CLR), including C#, J#, VB.NET and,
    with suitable extensions, Python and Perl.</p><p>The API provided by TMCore is based on the open API standard, TMAPI
    (see <a href="http://tmapi.org/" target="_top">http://tmapi.org/</a> for more
    details) which has been specified in Java. The TMCore API differs in that
    it makes use of features of C# and VB such as object properties and also
    provides a number of extra convenience functions for developers. However
    the full range of capabilities of TMAPI are present in the TMCore API (and
    much more besides!)</p><p>This document provides a guide to the TMCore APIs for developers.
    The examples are provided in the distribution in both C# and VB. In this
    document, however we show only the C# notation.</p><p>This guide is <span class="emphasis"><em>NOT</em></span> a method-by-method listing of
    all of the interfaces of the TMCore API. For such a listing, for this, the
    reader is directed to the HTML Help File
    <code class="filename">tmcore-api.chm</code> which is part of the TMCore
    distribution.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e26"></a>Acknowledgements</h2></div></div></div><p>Portions of this document are based on the TMAPI Developer's Guide
      and Quickstart document produced by the TMAPI project team.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e31"></a>Conventions Used</h2></div></div></div><p>This document uses a number of typographical convetions to
      highlight particular types of words or sections of text.</p><div class="itemizedlist"><ul type="disc"><li><p>Namespace, class and interface names are all displayed in a
          monospaced font. e.g
          <code class="interfacename">NetworkedPlanet.TMAPI</code>,
          <code class="interfacename">ITopic</code>.</p></li><li><p>Method names are displayed in a monospaced font. When
          referring to a particular overload of a method, the method
          parameters are displayed, otherwise they are omitted. The first time
          a method is referred to in the text, the method name is qualified by
          the interface or class that it is a member of e.g.
          <code class="methodname">ITopic.CreateTopicName()</code></p></li><li><p>File names are shown in bold monospaced font e.g.
          <code class="filename">App.config</code></p></li></ul></div><p>In addition the following conventions are used to highlight
      sections of the text:</p><div class="note"><h3 class="title">Note</h3><p>This is a note. A note highlights or expands on something
        mentioned in the text.</p></div><p></p><div class="warning"><h3 class="title">Warning</h3><p>This is a warning. A warning alerts you to a critical piece of
        information.</p></div><p></p><div class="programlisting"><pre>
      [1] // This is a program listing
      [2] // It contains a code snippet which is relevant to the text
      [3] // Lines may be numbered for references from the text</pre></div><p></p><div class="literallayout"><p>This&nbsp;is&nbsp;computer&nbsp;output<br>
It&nbsp;shows&nbsp;the&nbsp;text&nbsp;output&nbsp;that&nbsp;results<br>
from&nbsp;running&nbsp;a&nbsp;command-line&nbsp;application.<br>
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e71"></a>Summary Of Changes</h2></div></div></div><p>The following list shows the major changes to the API since
      TMCore05 SP1. Changes are listed as CRITICAL, NEW or UPDATED. A CRITICAL
      change is one which requires attention to any applications written with
      an older version of TMCore - this category includes all changes that
      might break an existing application when moving to the new version of
      the library. A NEW change is one which introduces new functionality to
      TMCore. An UPDATED change is one which modifies existing functionality
      without causing backwards compatibility issues.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e76"></a>Changes In TMCore07 SP3</h3></div></div></div><p>This section lists the major changes introduced in TMCore07 Service Pack 3.</p><div class="itemizedlist"><ul type="disc"><li><p>NEW: Added stored procedures for duplicate removal. Two new public stored procedures
      have been added to the database that identify and remove duplicate information from 
      either a single topic map or from all topic maps in the database. Refer to <a href="#duplicate.removal" title="Duplicate Removal Procedures">the section called &#8220;Duplicate Removal Procedures&#8221;</a> for more details.</p></li><li><p>NEW: A new API has been made available for performing fast transactional updates
      to a topic map. This new API allows developers to create and delete objects as well as
      modify existing objects. Because the API is implemented as direct database updates,
      a series of topic map updates written using the API is typically many times faster 
      than the equivalent series of updates written using TMAPI. Refer to <a href="#transactional.api" title="Chapter&nbsp;10.&nbsp;Fast Topic Map Updates with the TransactionalPersistenceManager">Chapter&nbsp;10, <i>Fast Topic Map Updates with the TransactionalPersistenceManager</i></a>
      for more details.</p></li><li><p>UPDATED: The NPCL Forms Schema has been extended to return additional information
      useful in creating topic map editing interfaces. In particular the schema provides 
      information about the database OIDs of the difference topic, association, role and occurrence types;
      the schema provides additional information about the cardinality constraints of each topic; and
      the forms schema now also properly reports all the role player types allowed in a role when
      the role player constraint omits the optional association type.</p><p>The updated schema is described in detail in the Web Services Guide document.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e97"></a>Changes In TMCore07</h3></div></div></div><p>This section lists the the major changes introduced in TMCore07</p><div class="itemizedlist"><ul type="disc"><li><p>NEW: The ITopicMapObject interface now exposes a new readonly
      property ID. This presents the object identifier as a 32-bit
      integer.</p></li><li><p>NEW: The ITopicMapSystem interface now exposes two overrides for
      the ExecuteQuery method. These overrides allow you to specify SQL
      parameters in a TMRQL query string and provide values for those
      parameters rather than relying on string concatenation. It is STRONGLY
      RECOMMENDED that you use these overrides in preference to the original
      ExceuteQuery(String) method. Refer to <a href="#executing.queries" title="Executing Queries">the section called &#8220;Executing Queries&#8221;</a> for more details.</p></li><li><p>NEW: A new assembly NetworkedPlanet.Npcl provides APIs for
      creating and reading topic map schema information using the Networked
      Planet Constraint Language (NPCL). Refer to <a href="#npcl-api" title="Chapter&nbsp;12.&nbsp;The NPCL Constraints API">Chapter&nbsp;12, <i>The NPCL Constraints API</i></a>
      for more information about these APIs.</p></li><li><p>NEW: A new web service application, npclws implements the NPCL
      Schema Web Service. This provides access to retrieve an XML
      representation of the NPCL schema governing a topic map or a single
      topic type within a topic map. Refer to the Web Service Guide for more
      information. The operations of this web service can be accessed via SOAP
      or using HTTP GET or POST requests.</p></li><li><p>NEW: New views have been added to the database to allow querying
      of the NPCL schema information in a topic map using TMRQL. See the
      TMCore Query Reference Sheet for an overview of these new views. The
      new veiws can be easily identified as their names all start with the
      prefix "tm_npcl".</p></li><li><p>UPDATED: The serviceclient.dll assembly that in previous versions
      contained only the SOAP web service stubs for the Topic Map Web Service
      now also contains the SOAP web service stubs for the NPCL Schema Web
      Service and classes for representing the structure of input and output
      XML used by the web services.</p></li><li><p>NEW: A new database user-defined function, tm_tc3 has been added.
      This function performs a transitive closure starting from a specified
      topic and using a set of association types and role types to determine
      the paths traversed.</p></li><li><p>UPDATED: The Topic Map Web Service now implements a new operation
      named ProcessTransaction. This operation allows a set of updates to a
      topic map to be described as a simple XML document and passed to the web
      service for processing as a single update transaction. This operation
      is, in most cases, far more efficient at updating specific topics and
      associations than the previously supported Save operation. However, the
      Save operation remains part of the Topic Map Web Service interface to
      enable efficient creation of new topics and associations in a topic map.
      For more details about this operation, please refer to the Web Services
      Guide.</p></li><li><p>NEW: The Topic Map Web Service now provides an ASP.NET-based
      implementation of the service allowing access to the operations using
      HTTP GET or HTTP POST requests. Unlike the SOAP HTTP transport, these
      interfaces implement all of the operations of the Topic Map Web
      Service.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e134"></a>Changes Prior To TMCore07</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>CRITICAL : The namespace NetworkedPlanet.TMAPI.Utils is now
            deprecated. All utility classes can be found in the namespace
            NetworkedPlanet.TMCore.Utils. The HierarchyManager class which was
            found in NetworkedPlanet.TMAPI.Utils has been moved, although an
            implementation remains under the old namespace for this release
            only to aid in any transition.</p></li><li><p>NEW: The class
            NetworkedPlanet.TMCore.Utils.ApplicationOntology provides
            utilities for managing cached references to topics that can be
            particularly useful in creating more readable and more efficient
            TMRQL queries. For more details please refer to <a href="#ApplicationOntology" title="The ApplicationOntology Object">the section called &#8220;The ApplicationOntology Object&#8221;</a>.</p></li><li><p>NEW: Two new methods are added to the interface
            NetworkedPlanet.TMAPI.Query.ITMCoreDataReader. The method
            ITMCoreDataReader.GetInternalDataReader() returns the underlying
            IDataReader instance wrapped by the ITMCoreDataReader instance.
            The method ITMCoreDataReader.GetDataTable() reads from the data
            reader and returns DataTable instance containing the full results
            set. For more details please refer to <a href="#executing.queries" title="Executing Queries">the section called &#8220;Executing Queries&#8221;</a>.</p></li><li><p>NEW: The public methods ITopic.Reload() and
            IAssociation.Reload() have been added to allow the local copy of a
            topic or association to be updated from the database, overwriting
            any local modifications.</p></li><li><p>NEW: A new public user-defined function in the database,
            tm_tc2 can be used to compute a transitive closure returning a
            list of {start, end} pairs that can hugely improve the time taken
            to process a hierarchy of topics. For more details, please refer
            to the separate Query Reference Sheet.</p></li></ul></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e157"></a>Chapter&nbsp;2.&nbsp;Before You Get Started</h2></div></div></div><p>This document contains sample code that you can compile and run
    against your own installation of TMCore. Of course, in order to do that
    there are certain prerequisites. The main prerequisite is that you are
    able to connect to a SQLServer database that has been configured with the
    TMCore schemas. Either you or your systems administrator can set up such a
    database by following the instructions contained in the TMCore
    Installation Guide. Once the database is set up, you will need the
    following information:</p><div class="orderedlist"><ol type="1"><li><p>The hostname or IP address of the SQLServer that hosts the
        TMCore database you are using for your testing.</p></li><li><p>The name of the TMCore database you are using for your
        testing.</p></li><li><p>The type of authentication required to connect to the database
        and any user name and password information. A SQLServer database
        supports Windows-based authentication (which makes use of your Windows
        logon to determine if you are allowed to access the database) and can
        also support database-specific user name and password. Your systems
        administrator will be able to tell you which is configured for your
        database. If you are connecting using your Windows logon, you need to
        make sure that you have been granted the necessary access privileges.
        These are detailed in the TMCore Installation Guide. If you are
        connecting using a database-specific user name and password, you will
        need that information.</p></li></ol></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e172"></a>Chapter&nbsp;3.&nbsp;TMCore API Programming Kickstart</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#compiling-examples">Compiling and Running the Examples</a></span></dt><dt><span class="section"><a href="#d0e201">APIExample1 : Creating a topic map with topics and
      associations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e447">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e458">APIExample2 : Working With Indexes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e557">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e562">APIExample3 : Reading And Writing XTM with IXTMProcessor</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e668">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e675">APIExample4: Using TMRQL</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e771">Running The Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e780">APIExample5: Using The ApplicationOntology Cache</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e819">Running The Example</a></span></dt></dl></dd></dl></div><p>This chapter presents some easy examples of how to start working
    with the TMCore API. The following examples are a little bit more than the
    typical "Hello World" application you find at the start of programming
    texts. Our first example provides code for creating a topic map from
    scratch using the TMCore APIs. The second example is a bit more complex,
    it generates a topic map that represents the directories and files
    contained in a given directory on the file-system. This second example
    shows more use of the APIs for creating and modifying topic map data and
    also shows the use of the indexing system provided by the API. The third
    example shows how to write a topic map out to an XTM file and the final
    example shows how to import topic map data from an XTM into the TMCore
    system.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compiling-examples"></a>Compiling and Running the Examples</h2></div></div></div><p>The full source code for these examples can be found in the
      <code class="filename">examples/</code> directory of the TMCore distribution. The
      directory contains both C# and VB.NET versions of the examples in the
      subdirectories CS and VB respectively. Each example is provided in a
      separate directory with its own project file. To compile and run an
      example, open Visual Studio.NET and create a new blank solution; then
      add the .csproj or .vbproj for the example to the solution. The project
      can then be built using the Build &gt; Build Solution menu item. If the
      solution contains multiple projects, set the new example project to be
      the start-up project by right clicking the project in the Solution
      Explorer pane and selecting "Set as StartUp Project" from the pop-up
      menu.</p><p>Some of the examples allow command line parameters to be
      specified. From within Visual Studio, you can assign the command line
      parameters to be used when running an example by bringing up the
      Properties pane for the project (right click on the project in the
      Solution Explorer and select "Properties"). In the Properties Pane
      select the item "Debugging" under "Configuration Properties" and in the
      field labelled "Command line arguments", enter the parameters. However,
      all of the example programs are written so that they can be run from
      within Visual Studio without specifying any command line
      parameters.</p><p>Finally, to run the project, press F5 or choose the Debug &gt;
      Start menu item.</p><div class="note"><h3 class="title">Note</h3><p>You may find that the project files contain an invalid reference
        to the TMCore assembly. You can check this by opening the "References"
        icon under the project name in the solution explorer of Visual studio.
        If you see the reference named "tmcore" with a yellow warning triangle
        next to it, then the reference is invalid and must be changed before
        you can successfully compile the project. To change the reference,
        delete the existing reference and then right click on the "References"
        icon and select <b><span class="guimenuitem">Add Reference</span></b>. In the
        dialog that is displayed, click <b><span class="guibutton">Browse...</span></b> and
        browse to the tmcore.dll that came with the TMCore installation.
        Finally, click the <b><span class="guibutton">OK</span></b> button to dismiss the
        dialog. You should now see the tmcore reference appear under
        "References" with no warning triangle next to it.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e201"></a>APIExample1 : Creating a topic map with topics and
      associations</h2></div></div></div><p>This section contains a little example of how to create a topic
      map including two topics and an association. This example also prints
      the content of the topic map. This example can be found in the directory
      <code class="filename">examples/CS/APIExample1</code> or
      <code class="filename">examples/VB/APIExample1</code>.</p><div class="example"><a name="simple-create"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Creating a Topic Map</b></p><div class="programlisting"><pre>
      [1] // Initialise the TMCore connection using applicaton configuration settings
      [2] ITopicMapSystem tmSystem = TopicMapSystemFactory.GetTopicMapSystem();
      [4] // Create a new topic map to work in
      [5] ITopicMap tm = tmSystem.CreateTopicMap("http://www.example.com/topicmaps/MyFirstTopicMap");</pre></div></div><p>In line 2 the static method
      <code class="methodname">TopicMapSystemFactory.GetTopicMapSystem()</code> is
      invoked to create and return a new
      <code class="interfacename">ITopicMapSystem</code> instance. The
      no-arguments version of <code class="methodname">GetTopicMapSystem()</code>
      uses the application's configuration file
      (<code class="filename">APIExample1.exe.config</code>) to provide the necessary
      configuration information. If you are running this application in the
      Visual Studio.NET IDE, the file used is the file
      <code class="filename">App.config</code>. An example
      <code class="filename">App.config</code> is shown below. For a more in-depth look
      on whats happening here, please refer to <a href="#TopicMapSystem_TopicMapSystemFactory" title="ITopicMapSystem and TopicMapSystemFactory">the section called &#8220;ITopicMapSystem and TopicMapSystemFactory&#8221;</a>. In line 4 a topic map
      with the name "http://www.example.com/topicmaps/MyFirstTopicMap" is
      created.</p><div class="example"><a name="d0e239"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;Topic Map Application Configuration File</b></p><div class="programlisting"><pre>
      [1] &lt;configuration&gt;
      [2]   &lt;appSettings&gt;
      [3]     &lt;add key="networkedplanet.tmcore.dbconnect"
      [4]          value="Data Source=localhost;Integrated Security=SSPI; Initial Catalog=topicmap" /&gt;
      [5]   &lt;/appSettings&gt;
      [6] &lt;/configuration&gt;</pre></div></div><p>A topic map's name is a unique identifier for the topic map within
      the TMCore system. Because of this, if you ran an application with the
      above example code in it twice, you would get a TopicMapExistsException
      thrown on the second occasion, informing you that a topic map with the
      specified name already exists. Instead, you should write code that
      checks that you are not about to create a topic map with a name that is
      already in use and take the appropriate action if there is. So rather
      than use the simple code shown in <a href="#simple-create" title="Example&nbsp;3.1.&nbsp;Creating a Topic Map">Example&nbsp;3.1, &#8220;Creating a Topic Map&#8221;</a>,
      something like the following code should be invoked:</p><div class="example"><a name="d0e248"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;Safely Creating a Topic Map</b></p><p>
          </p><div class="programlisting"><pre>
      [1] private static ITopicMap SafeCreateTM(ITopicMapSystem tms, string name) 
      [2] {
      [3]   ITopicMap tm = tms.GetTopicMap(name);
      [4]   if (tm != null) 
      [5]   {
      [6]     tm.Remove();
      [7]   }
      [8]   return tms.CreateTopicMap(name);
      [9] }</pre></div><p>
        </p></div><p>On line 3, an attempt is made to retrieve a topic map with the
      base locator of the topic map we want to create. If a topic map is
      found, we cannot create the new topic map directly. In this example, the
      solution is simply to remove the topic map from the system. This is done
      using the call to <code class="methodname">ITopicMap.Remove()</code> on line 6.
      The <code class="methodname">Remove()</code> method removes the topic map and
      all topics and associations that it contains from the system.
      Alternatively you may choose to retry using some algorithm for
      generating a new name string that does not already exist or perhaps even
      prompt the application user for a new topic map name. Finally on line 8
      the topic map is created. In this case, because any pre-existing topic
      map with the same name has been removed, the call to the
      <code class="methodname">CreateTopicMap()</code> method will succeed.</p><div class="example"><a name="d0e267"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Creating and Populating Topics</b></p><div class="programlisting"><pre>
      [1] // Create topics
      [2] ITopic t1 = tm.CreateTopic();
      [3] t1.CreateTopicName("hello");
      [4] t1.Save();
      [6] ITopic t2 = tm.CreateTopic();
      [7] t2.CreateTopicName("world");
      [8] t2.Save();</pre></div></div><p>Creating a new topic in a topic map is as easy as calling the
      <code class="methodname">CreateTopic()</code> method on the ITopicMap instance.
      The result of this method is a new <code class="interfacename">ITopic</code>
      instance. The ITopic interface provides methods for creating new topic
      names and occurrences. This is the pattern used throughout the TMCore
      API - to create a new object, you call the appropriate
      <code class="methodname">Create...()</code> method on the parent object. Some
      <code class="methodname">Create...()</code> methods are overloaded with
      different parameter lists to allow you to specify the content of the new
      object, so in this example the call to
      <code class="methodname">CreateTopicName()</code> on lines 3 and 7 take a
      single string parameter which is the string value of the newly created
      <code class="interfacename">ITopicName</code> instance.</p><p>When an object is modified, the changes are not committed to the
      topic map until the <code class="methodname">Save()</code> method is called.
      The <code class="methodname">Save()</code> method is provided on the
      <code class="interfacename">ITopic</code> and the
      <code class="interfacename">IAssociation</code> interfaces only. To save a
      change to a topic name or occurrence you must call the
      <code class="methodname">Save()</code> method on the containing
      <code class="interfacename">ITopic</code>. To save a change to an
      <code class="interfacename">IAssociationRole</code> instance you must call
      the <code class="methodname">Save()</code> method on the containing
      <code class="interfacename">IAssociation</code> instance. Calling the
      <code class="methodname">Save()</code> method saves all of the changes made to
      the <code class="interfacename">ITopic</code> or
      <code class="interfacename">IAssociation</code> instance and the saving
      takes place in a single database transaction - either all updates are
      saved or, in the case of an error, none of the changes are saved.</p><p>In addition to <code class="methodname">Save()</code> methods on
      <code class="interfacename">ITopic</code> and
      <code class="interfacename">IAssociation</code>, the
      <code class="interfacename">ITopicMap</code> interface also provides a
      <code class="methodname">Save()</code> method. Invoking this
      <code class="methodname">ITopicMap.Save()</code> on a topic map will result in
      all changes to contained <code class="interfacename">ITopic</code> and
      <code class="interfacename">IAssociation</code> instances being committed in
      a single transaction.</p><div class="example"><a name="d0e356"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Creating and Populating Associations</b></p><div class="programlisting"><pre>
      [1] // Create an association between the topics
      [2] IAssociation a = tm.CreateAssociation();
      [3] a.CreateAssociationRole(t1, null);
      [4] a.CreateAssociationRole(t2, null);
      [5] a.Save();</pre></div></div><p>Creating an association follows the same pattern as creating a
      topic. The <code class="interfacename">IAssociation</code> instance is
      created using the <code class="methodname">CreateAssociation()</code> method of
      the <code class="interfacename">ITopicMap</code> interface (line [2]).
      <code class="interfacename">IAssociationRole</code> instances specify the
      topics that participate in the association and are created using the
      <code class="methodname">CreateAssociationRole()</code> method of the
      <code class="interfacename">IAssociation</code> interface. This method takes
      two parameters, the first is the <code class="interfacename">ITopic</code>
      that is participating in the association and the second is an
      <code class="interfacename">ITopic</code> instance that specifies the type
      of role played by the first topic in the association. Either of these
      parameters may be null. As with the
      <code class="interfacename">ITopic</code> interface, changes made are not
      committed to the database until the
      <code class="methodname">ITopic.Save()</code> method is called.</p><div class="example"><a name="d0e393"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;Looping over Topics and Associations</b></p><p>
          </p><pre class="programlisting">// Print out the names of each topic in the topic map
foreach(ITopic t in tm.Topics) 
{
  PrintTopicNames(t);
}

// Print out the role players of each association in the topic map
foreach(IAssociation assoc in tm.Associations) 
{
  PrintAssociation(assoc);
}
</pre><p>
        </p></div><p>The <code class="interfacename">ITopicMap</code> interface provides
      read-only properties <span class="property">Topics</span> and
      <span class="property">Associations</span>. These return an
      <code class="interfacename">IList</code> of the topics or associations in
      the topic map. Although these properties make it extremely easy to
      iterate over the contents of a topic map in a simple application like
      this, with large topic maps any simple listing of all topics or all
      associations will quickly become difficult to display and potentially
      quite slow as you trawl through the whole database! However, for our
      simple Hello World application, these properties are extremely
      convenient.</p><div class="example"><a name="d0e415"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;Accessing Topic Data</b></p><pre class="programlisting">private static void PrintTopicNames(ITopic t) 
{
  System.Console.Write("Topic: ");
  foreach(ITopicName tn in t.TopicNames) 
  {
    System.Console.Write("{0} ", tn.Value);
  }
  System.Console.WriteLine();
}
</pre></div><p>Accessing data is as simple as using the properties defined by
      each interface. In the example code above, the names of a topic are
      returned by the <span class="property">ITopic.TopicNames</span> property which is
      a read-only <code class="interfacename">IList</code> of
      <code class="interfacename">ITopicName</code> instances. The string value of
      a topic name is accessed using the <span class="property">ITopicName.Value</span>
      property which is a read-write property.</p><p>The rule-of-thumb for whether a property will be read-only or
      read-write is that if the property gives access to the parent or
      children of an object, it will be read-only (you must use the
      <code class="methodname">Create...()</code> and
      <code class="methodname">Remove()</code> methods to manage parent-child
      relationships). For other properties, access is read-write. So if we
      wanted to update a topic name's string value it would be as simple as
      :</p><p>
        </p><pre class="programlisting">tn.Value = "My New Name";</pre><p>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e447"></a>Running The Example</h3></div></div></div><p>This small example showed how to create a topic map with 2
        topics, named "hello" and "world", and an association between these
        topics. You can compile and run this example as described in <a href="#compiling-examples" title="Compiling and Running the Examples">the section called &#8220;Compiling and Running the Examples&#8221;</a>. This example does not require any
        command line arguments.</p><p>The output of this example should be as shown below:</p><div class="literallayout"><p>Topic&nbsp;:&nbsp;hello<br>
Topic&nbsp;:&nbsp;world<br>
Association&nbsp;Role&nbsp;Players:<br>
Topic&nbsp;:&nbsp;hello<br>
Topic&nbsp;:&nbsp;world<br>
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e458"></a>APIExample2 : Working With Indexes</h2></div></div></div><p>APIExample2 is a simple application which shows the basics of
      using the programmatic indexes provided by TMCore. The program creates a
      topic map from a directory (specified on the command line) and all its
      subdirectories. For each directory and file in the hierarchy a topic is
      created and assigned either the type "File" or "Directory" (these are
      defined by separate topics created when the program first initialises).
      For each file and for each subdirectory of the starting directory an
      association is created to the containing directory. That association is
      typed as "Parent-Child" with the containing directory playing a role of
      type "Parent" and the contained file or directory topic playing the role
      "Child". In addition, every file with a file name extension (eg.
      MyFile.txt ) is also typed by a topic that describes the extension (e.g.
      ".TXT"). The first time that a file with a particular extension is
      encountered, the typing topic is created. For each subsequent file with
      the same extension, that same topic is used. To assign the right
      extension type topic to a file topic, the
      <code class="classname">org.tmapi.index.core.TopicsIndex</code> is used to look
      up the extension type topic.</p><p>This example can be found in the file
      <code class="filename">examples/CS/APIExample2</code> for C# code and
      <code class="filename">examples/VB/APIExample2</code> for VB code.</p><div class="example"><a name="d0e474"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;The Main Program Flow</b></p><pre class="programlisting">public void Run(string startDirectory) 
{
  // Initialise a new ITopicMapSystem and create the topic map
  m_tmSystem = TopicMapSystemFactory.GetTopicMapSystem();
  m_tm = SafeCreateTM(m_tmSystem, "http://www.example.com/topicmaps/MyFileSystem");

  // Add the basic topics required for creating our file-system topic map
  CreateOntology();

  ProcessDirectory(new DirectoryInfo(startDirectory), null);

  ListTopicsAndAssociations();
  ListTopicTypes();
  ListDLLs();
}</pre></div><p>When the program is run, the name of the directory to process is
      retrieved from the command-line (not shown in the code above). This is
      passed into the main program loop as the parameter startDirectory. In
      the main program loop, the following is done:</p><div class="orderedlist"><ol type="1"><li><p>A new TopicMapSystem is created and a new TopicMap is created
          in that system. This code is exactly the same as already discussed
          for APIExample1.</p></li><li><p>The CreateOntology() method is invoked to "bootstrap" the
          topic map with the topics that define the basic topic types of
          "File", "Directory" and the basic association type "Parent-Child"
          and role types "Parent" and "Child".</p></li><li><p>The ProcessDirectory() method is invoked to recurse through
          the directory specified by the startDirectory parameter, creating
          File and Directory topics and linking them together using
          Parent-Child associations.</p></li><li><p>All of the topics and associations created are listed to the
          console by the method ListTopicsAndAssociations(). This method makes
          use of code very similar to that already seen in APIExample1 and
          will not be covered in detail here.</p></li><li><p>All of the topics used to type other topics are listed to the
          console by the method ListTopicTypes().</p></li><li><p>All of the topics of a specific type (the type representing
          files with the .DLL extension) are listed to the console by the
          method ListDLLs();</p></li></ol></div><div class="example"><a name="d0e500"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Creating the Topic Map Ontology</b></p><pre class="programlisting">/// &lt;summary&gt;
/// Creates the topics for the basic types used by this topic map.
/// &lt;/summary&gt;
private void CreateOntology() 
{
  // Topic to type all topics that represent files
  m_tFile = CreateTopic("File", "http://www.networkedplanet.com/psi/examples/#File")
  // Topic to type all topics that represent directories
  m_tDirectory = CreateTopic("Directory", "http://www.networkedplanet.com/psi/examples/#Directory");

  // Topics for creating the Parent/Child associations
  m_tParent = CreateTopic("Parent", "http://www.networkedplanet.com/psi/examples/#Parent");
  m_tChild = CreateTopic("Child", "http://www.networkedplanet.com/psi/examples/#Child");
  m_tParentChild = CreateTopic("Parent-Child", "http://www.networkedplanet.com/psi/examples/#ParentChild");
}

/// &lt;summary&gt;
/// Utility method to create a topic with a single name and a 
/// single subject identifier.
/// &lt;/summary&gt;
/// &lt;param name="name"&gt;The name to add to the new topic&lt;/param&gt;
/// &lt;param name="subjectIdentifier"&gt;The subject identifier URL for the new topic&lt;/param&gt;
/// &lt;returns&gt;The newly created topic&lt;/returns&gt;
private ITopic CreateTopic(string name, string subjectIdentifier) 
{
  ITopic ret = m_tm.CreateTopic();
  ret.CreateTopicName(name);
  if (subjectIdentifier != null) 
  {
    ret.AddSubjectIdentifier(m_tm.CreateLocator(subjectIdentifier));
  }
  ret.Save();
  return ret;
}
</pre></div><p>The above code shows one simple pattern for populating a new topic
      map with the basic typing topics for an application (often called an
      'ontology'). The method CreateTopic() is used to create a single topic
      with a given name and subject identifier. This method is then invoked
      from the CreateOntology() method for each topic to be created. Of
      course, if your application will make use of the same topic map each
      time, you should check that a particular topic does not exist before
      creating a new one with the same subject identifier - we will see how to
      use indexes to achieve this in the next section. In this code, the
      topics are then stored as member variables of the main program class -
      in more complex applications you may want to create a specific
      "Ontology" class to manage these topics.</p><div class="example"><a name="d0e507"></a><p class="title"><b>Example&nbsp;3.10.&nbsp;Using Indexes</b></p><div class="programlisting"><pre>
      [1] /// &lt;summary&gt;
      [2] /// Adds a topic representing a file into the topic map.
      [3] /// &lt;/summary&gt;
      [4] /// &lt;param name="fileInfo"&gt;The file to be processed.&lt;/param&gt;
      [5] /// &lt;param name="parentDir"&gt;The topic representing the directory that contains this file.&lt;/param&gt;
      [6] private void ProcessFile(FileInfo fileInfo, ITopic parentDir) 
      [7] {
      [8]   // Create a topic representing the file
      [9]   ITopic fileTopic = m_tm.CreateTopic();
      [10]   fileTopic.AddType(m_tFile);
      [11]   fileTopic.CreateTopicName(fileInfo.FullName);
      [12]   fileTopic.CreateTopicName(fileInfo.Name, new ITopic[] {parentDir});
      [14]   if (fileInfo.Extension != null) 
      [15]   {
      [16]     // Lookup the topic that represents this file's file extension
      [17]     string fileTypeIdentifier = 
      [18]       "http://www.networkedplanet.com/psi/examples/extensions/#" + 
      [19]       fileInfo.Extension.Substring(1).ToUpper();
      [21]     ITopic extensionType = m_tm.TopicsIndex.GetTopicBySubjectIdentifier(fileTypeIdentifier);
      [22]     if (extensionType == null) 
      [23]     {
      [24]       // Create a topic to represent this files's file extension
      [25]       extensionType = m_tm.CreateTopic();
      [26]       extensionType.CreateTopicName("File Type: " + fileInfo.Extension.ToUpper());
      [27]       extensionType.AddSubjectIdentifier(fileTypeIdentifier);
      [28]       extensionType.Save();
      [29]     }
      [30]     fileTopic.AddType(extensionType);
      [31]   }
      [33]   fileTopic.Save();
      [34]   ...
      [35] }</pre></div></div><p>The code snippet above shows part of the process of creating a
      topic to represent a file. From line [14] to line [31] is code for
      assigning a type to the file topic based on the extension of the file
      name. So for example all files representing .DLL files will be typed by
      a topic "DLL", all .TXT files by a topic "TXT" and so on. We want to be
      sure that we only create the "DLL" or "TXT" topic on the first time we
      encounter a file with that extension and not on subsequent files with
      the same extension. The best way to identify topics is by assigning a
      subject identifier to them. A subject identifier is simply a unique URI
      identifier for the topic. In our example we create a subject identifier
      with the URI
      "http://www.networkedplanet.com/psi/examples/extensions/#{extension}".
      Note that we force the file name extension to upper case to ensure that
      "X.DLL" and "y.dll" both receive the same typing topic as subject
      identifiers are case-sensitive. Having created a locator string with the
      appropriate URL (lines [17]-[19]), we then look up the topic with that
      subject identifier using the <span class="property">
          <span class="property">TopicsIndex</span>
        </span>. Every <code class="interfacename">ITopicMap</code> provides
      access to a set of indexes of the different objects in the topic map.
      All of these indexes are accessed through read-only properties of the
      <code class="interfacename">ITopicMap</code> interface - they are easily
      identified as each property name ends with "Index". Each of the indexes
      provide a different set of look-up methods. The index we are using here,
      the <span class="property">TopicsIndex</span> provides methods to look up a topic
      by its subject identifier, its subject locator, or its type(s). On line
      21, the method
      <code class="methodname">ITopicsIndex.GetTopicBySubjectIdentifier()</code> is
      invoked. Because a topic map can only ever have one topic with a given
      subject identifier, this method will either return a single
      <code class="interfacename">ITopic</code> instance or null. If the method
      returns null, a new topic is created on lines 24-28. Finally the topic
      (either the one returned by
      <code class="methodname">GetTopicBySubjectIdentifier()</code> or the newly
      created topic) is added to the types for the file topic using the method
      <code class="methodname">ITopic.AddType()</code>, and the file topic is saved
      to commit all the changes.</p><div class="example"><a name="d0e541"></a><p class="title"><b>Example&nbsp;3.11.&nbsp;Listing All Topic Types</b></p><div class="programlisting"><pre>
      [1] /// &lt;summary&gt;
      [2] /// Displays the topics which are used to type other topics in the topic map.
      [3] /// &lt;/summary&gt;
      [4] private void ListTopicTypes()
      [5] {
      [6]   System.Console.WriteLine("All Topic Types:");
      [7]   IList topicTypes = m_tm.TopicsIndex.GetTopicTypes();
      [8]   foreach(ITopic t in topicTypes) 
      [9]   {
      [10]     PrintTopicNames(t);
      [11]   }
      [12]   System.Console.WriteLine();
      [13] }</pre></div><p>The example above shows another use of the indexes. In addition
        to allowing you to look up objects by certain properties, most of the
        indexes also allow you to do a reverse look up e.g. to quickly find
        all topics which are used to type other topics. These reverse look up
        methods can be extremely useful in constructing views and indexes for
        the user. In this example the reverse look up is to find all topics
        which are used to type other topics in the topic map and is achieved
        on line [7] with a call to
        <code class="methodname">ITopicsIndex.GetTopicTypes()</code>, which returns
        an <code class="interfacename">IList</code> of
        <code class="interfacename">ITopic</code> instances.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e557"></a>Running The Example</h3></div></div></div><p>This example program requires a single command line parameter
        which specifies the directory where the listing is to start. If this
        directory is not specified, it defaults to the working directory in
        which the application is run. The default value should enable the
        application to be run from within Visual Studio without having to
        modify the command line arguments property of the project.The output
        generated by the application will depend upon the directory you
        choose.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e562"></a>APIExample3 : Reading And Writing XTM with IXTMProcessor</h2></div></div></div><p>APIExample3 extends the file system topic map example from the
      previous section to show how XTM files can be imported into and exported
      from TMCore. The APIExample3 application :</p><div class="orderedlist"><ol type="1"><li><p>Reads the basic ontology from an XTM file.</p></li><li><p>Writes the file system topic map to an XTM file.</p></li></ol></div><div class="example"><a name="d0e574"></a><p class="title"><b>Example&nbsp;3.12.&nbsp;Reading An XTM File</b></p><pre class="programlisting">/// &lt;summary&gt;
/// Reads the topics for the basic types used by this topic map.
/// &lt;/summary&gt;
private void ReadOntology(string ontologyName, string tmName) 
{
  IXTMProcessor ixtmp = m_tmSystem.GetXTMProcessor();
  ixtmp.ImportXTM(File.OpenRead(ontologyName), 
    new Uri("http://www.networkedplanet.com/examples/directory.xtm"),
    tmName);
  string idBase = "http://www.networkedplanet.com/psi/examples/";
  m_tFile = GetTopic(idBase + "#File");
  m_tDirectory = GetTopic(idBase + "#Directory");
  m_tParentChild = GetTopic(idBase + "#ParentChild");
  m_tParent = GetTopic(idBase + "#Parent");
  m_tChild = GetTopic(idBase + "#Child");
}
</pre><p>The code example above shows how to import an XTM file into the
        TMCore system. The import is done using an
        <code class="interfacename">IXTMProcessor</code> instance. The
        <code class="interfacename">IXTMProcessor</code> interface defines methods
        for the import and export of XTM syntax topic maps from TMCore. An
        IXTMProcessor instance is retrieved using the method
        <code class="methodname">ITopicMapSystem.GetXTMProcessor()</code>. The import
        is performed using the ImportXTM method which has the following method
        signature:</p><p>
          <code class="methodsynopsis"><span class="type">ITopicMap&nbsp;</span><span class="methodname">ImportXTM</span>(<span class="methodparam"><span class="type">System.IO.Stream&nbsp;</span><span class="parameter">input</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">System.Uri&nbsp;</span><span class="parameter">srcLoc</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">string&nbsp;</span><span class="parameter">name</span></span>);</code>
        </p><p>The parameter <em class="parameter"><code>input</code></em> specifies the stream
        from which the XTM data is to be read. The stream may be from an open
        file, from an HTTP connection or from any other data source that can
        provide a stream. The <em class="parameter"><code>srcLoc</code></em> parameter
        specifies the source URI for the data stream. The source URI is used
        for the resolution of any relative paths found in the XTM data. For
        example, in the code snippet above the <em class="parameter"><code>srcLoc</code></em>
        parameter is specified as
        "http://www.networkedplanet.com/examples/directory.xtm". If that XTM
        file contained a reference "../index.html", then the reference would
        be expanded to "http://www.networkedplanet.com/examples/index.html.
        The source URI is also recorded in the
        <span class="property">SourceLocators</span> property of the
        <code class="interfacename">ITopicMap </code>instance that receives the
        XTM data. The <em class="parameter"><code>name</code></em> parameter specifies the name
        of the topic map into which the data is to be imported. If a topic map
        with the specified name does not already exist, it will be created. If
        a topic map with the specified name does exist, then the topic map
        data will be merged into the existing topic map.</p></div><div class="example"><a name="d0e633"></a><p class="title"><b>Example&nbsp;3.13.&nbsp;Writing An XTM File</b></p><pre class="programlisting">private void WriteTopicMap(FileStream outputStream) 
{
  IXTMProcessor xtmp = m_tmSystem.GetXTMProcessor();
  xtmp.ExportXTM(new StreamWriter(outputStream), m_tm);
}
</pre><p>The code example above shows that exporting a topic map as XTM
        data is even more straightforward. The method
        IXTMProcessor.ExportXTM() has the following signature:</p><code class="methodsynopsis"><span class="void">void&nbsp;</span><span class="methodname">ExportXTM</span>(<span class="methodparam"><span class="type">System.IO.StreamWriter&nbsp;</span><span class="parameter">ouput</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">ITopicMap&nbsp;</span><span class="parameter">tm</span></span>);</code><p>The parameter <em class="parameter"><code>output</code></em> provides a
        <code class="classname">StreamWriter</code> instance that will output to the
        stream on which the XTM data is to be written. This stream may connect
        to a file or to any other sink which accepts streamed data. The
        parameter <em class="parameter"><code>tm</code></em> specifies the
        <code class="interfacename">ITopicMap</code> instance to be
        exported.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e668"></a>Running The Example</h3></div></div></div><p>This example program requires two command line arguments. The
        first specifies the path to the XTM file that provides the ontology
        for the application. If not specified, this first parameter defaults
        to the file "ontology.xtm" located in the current working directory.
        The second parameter specifies the directory from which the processing
        should start. If not specified, then this parameter defaults to the
        current working directory. These defaults should enable the
        application to be run from within Visual Studio without having to
        modify the command line arguments property of the project.</p><p>The output generated by the application will depend upon the
        directory you choose.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e675"></a>APIExample4: Using TMRQL</h2></div></div></div><p>APIExample4 shows how to use the TMRQL query language from your
      own code. TMRQL is simply SQL applied to a defined set of relational
      views of your topic map data. This makes TMRQL easy to use for anyone
      already familiar with SQL and also has the advantage of extensive
      support in tools an in code from the .NET Framework.</p><p>The code in APIExample4 performs the following steps:</p><div class="orderedlist"><ol type="1"><li><p>Import an XTM file into the database - this is the source data
          that will be queried. The source data is a partial genealogy of the
          British monarchy.</p></li><li><p>Execute a simple TMRQL query that finds all of the children of
          King William I (William the Conquerer) and list the IDs and names of
          the topics for those children.</p></li><li><p>Execute a more complex TMRQL query that makes use of a
          TMRQL-defined function that returns all descendants of King William
          I as a DataTable. That DataTable is then processed locally to create
          a simple tree view of the descendants.</p></li></ol></div><p>The code for importing the XTM file is contained in the method
      <code class="methodname">ImportXTMFile()</code> - this is similar to the code
      already seen in APIExample3 for XTM import.</p><p>The query for the direct children of William I is done in the
      method QueryChildren(). In this query, we want to find all topics
      associated with the topic for William I where the association type is
      "child-of" and William I plays the role "parent". William I, "child-of"
      and "parent" are all topics in the topic map an need to be found in the
      database to perform this query. In this example, this is done as part of
      th query itself, using the topic subject identifiers and looking up the
      topic's unique identifiers using SQL sub-selects. The actual query
      string used is slightly obscured by the use of string constants for the
      base URIs of the subject identifiers, so is reproduced here in its
      complete form except for the string <em class="replaceable"><code>{topicmap
      ID}</code></em> which is replaced with the
      <span class="property">ObjectID</span> of the
      <code class="interfacename">ITopicMap</code> object passed into the
      <code class="methodname">QueryChildren()</code> method:</p><pre class="programlisting">SELECT r2p, dbo.tm_displayName(r2p) FROM tm_assoc2 WHERE
  topicmap = <i>{topicmap ID}</i> AND 
  r1p in (SELECT topic_id from tm_si where subj_id='http://www.example.com/psi/uk-monarchs/william-i') AND 
  association_type in (SELECT topic_id from tm_si where subj_id='http://www.example.com/psi/family/child-of') AND
  r1t in (SELECT topic_id from tm_si where subj_id='http://www.example.com/psi/family/parent')</pre><p>The principal selection is done using the tm_assoc2 view which
      presents pairs of topics that are in the same association, giving the
      association type and the role type played by each topic. Each of the
      topics William I, "child-of" and "parent" are found using a lookup in
      the tm_si view which maps a topic's subject identifier to its unique
      object identifier. In the SELECT part of the query, the tm_displayName
      function is used to select one name from the topic specified in the
      function parameter. The query is executed using the
      <code class="methodname">ExecuteQuery()</code> method of the
      <code class="interfacename">ITopicMapSystem</code> interface, not on the
      <code class="interfacename">ITopicMap</code> interface. Although this query
      specifically restricts itself to a single topic map, but you can write
      queries that span multiple topic maps in the same database (although you
      will then need to be responsible for working out which results came from
      which topic map!). The exection and procesing of the results set is
      shown in the code snippet below.</p><pre class="programlisting">ITMCoreDataReader dr = tm.TopicMapSystem.ExecuteQuery(query);
System.Console.WriteLine("Children of William I:");
try 
{
  while (dr.Read()) 
  {
    int id = dr.GetInt32(0);
    string name = dr.GetString(1);
    System.Console.WriteLine("  {0} - {1}", id, name);
  }
} 
finally 
{
  dr.Close();
}</pre><p>The <code class="methodname">ExecuteQuery()</code> method returns an
      instance of the <code class="interfacename">ITMCoreDataReader</code>
      interface which extends the standard SQL DataReader implementation with
      additional methods that can return full TMAPI objects from object
      identifiers in the results set. As with a normal
      <code class="interfacename">DataReader</code>, you can call the
      <code class="methodname">Read()</code> method to retrieve results row by row
      until the method returns false (at which point you have reached the end
      of the results set). You can then use the various
      <code class="methodname">Get<em class="replaceable"><code>XXX</code></em>()</code> methods to
      retrieve individual items from the row - in this case the unique object
      identifier is retrieved as a 32-bit integer, and the topic name is
      retrieved as a string.</p><div class="warning"><h3 class="title">Warning</h3><p>You must always ensure that you call the
        <code class="methodname">Close()</code> method on the
        <code class="interfacename">ITMCoreDataReader</code> interface when you
        are done with it. Placing this call in the finally section of a try
        block is the easiest way to ensure that the data reader is always
        closed - even if an exception occurs when processing a row of the
        results set.</p></div><p>The method QueryDescendents() prints a tree-view of all
      descendants of William I. This list is found by following the "child-of"
      associations (from "parent" role to "child" role") starting from William
      I. We call this traversal of a specific type of association in a
      specific direction (from one role type to another role type) as
      transitive closure. TMRQL provides two functions for retrieving this
      transitive closure. The tm_tc function is provided for backwards
      compatibility, but we recommend you use the tm_tc2 function which
      returns a table listing each path in the transitive closure as a pair of
      topics - the "from" topic and the "to" topic. If you think of the
      transitive closure like a tree, the "from" topic is the parent node and
      the "to" topic is the child node.</p><div class="note"><h3 class="title">Note</h3><p>Although it is often the case that these functions are used to
        retrieve tree structures, in fact the tm_tc and tm_tc2 functions are
        capable of handling cyclic references as well as straightforward
        hierarchies.</p></div><p>This method also shows a different way of constructing a query
      that requires topic identifiers. Rather than querying for the
      identifiers within the query string itself, the topics are first located
      using the Index APIs to lookup the topics one by one. This can be useful
      when you write a lot of queries that use the same topics over and over
      again. The code for the QueryDescendants() method is shown below.</p><pre class="programlisting">string familyPsiBase = "http://www.example.com/psi/family/";
string monarchyPsiBase = "http://www.example.com/psi/uk-monarchs/";
ITopic childOf = tm.TopicsIndex.GetTopicBySubjectIdentifier(familyPsiBase + "child-of");
ITopic child = tm.TopicsIndex.GetTopicBySubjectIdentifier(familyPsiBase + "child");
ITopic parent = tm.TopicsIndex.GetTopicBySubjectIdentifier(familyPsiBase + "parent");
ITopic william = tm.TopicsIndex.GetTopicBySubjectIdentifier(monarchyPsiBase + "william-i");
string query = String.Format(
  "SELECT from_id, to_id, dbo.tm_displayName(to_id) as child_name from tm_tc2({0},{1},{2},{3})",
  william.ObjectID, childOf.ObjectID, parent.ObjectID, child.ObjectID);
try 
{
  ITMCoreDataReader dr = tm.TopicMapSystem.ExecuteQuery(query);
  System.Data.DataTable tbl = dr.GetDataTable();
  System.Console.WriteLine("William I:");
  ListChildren(tbl, Int32.Parse(william.ObjectID), 2);
} 
catch (Exception ex) 
{
  System.Console.WriteLine("ERROR: Caught error in processing query.");
  System.Console.WriteLine(ex.ToString());
}</pre><p>The first 6 lines of the code are used to find the topics that are
      required to execute the tm_tc2 function. This function requires the
      identifiers of the starting topic for the closure, the type of the
      association to be traversed, the type of role played by the "from" topic
      at each link in the path and the type of role played by the "to" topic
      at each link. Because these topics are located first using the Index
      API, the query string can be much simpler - requiring only that the
      ObjectID of each topic be inserted into the correct place in the query.
      This code example differs from the previous query in another way too.
      Rather than reading the results set row by row, the code makes use of
      the GetDataTable() method provided by the ITMCoreDataReader interface.
      This method reads all the rows from the results set into a local
      System.Data.DataTable instance and then closes the DataReader. For large
      results sets, this could potentially require a lot of memory, but it has
      several advantages. Firstly it means that you do not have to explicitly
      close the DataReader as this is done by the code that constructs the
      DataTable. Secondly, the DataTable interface provides a number of
      methods that allow you to filter and select from the results data
      without executing further queries against the database. This second
      feature is used by the method ListChildren() which is a recursive method
      used to construct the tree view. Each time the ListChildren() method is
      invoked, it selects from the DataTable all those rows where the "from"
      topic identifier matches the identifier specified in the input
      parameter. Then for each row it prints the id and name of the "to" topic
      (the child) and then calls itself with the child topic identifier as the
      parameter to print the list of the child's children and so on. This code
      is shown in the snippet below.</p><pre class="programlisting">private void ListChildren(System.Data.DataTable descendantsTable, int parentId, int indent)
{
  System.Data.DataRow[] children = descendantsTable.Select("from_id=" + parentId, "child_name");
  foreach(System.Data.DataRow childRow in children)
  {
    int childId = (int)childRow[1];
    string childName = childRow[2] as String;
    System.Console.WriteLine("{0}{1} - {2}", new String(' ', indent), childId, childName);
    ListChildren(descendantsTable, childId, indent + 2);
  }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e771"></a>Running The Example</h3></div></div></div><p>This example program requires a single command line argument
        that specifies the path to the XTM file that defines the data to be
        queried. The example file kings_and_queens.xtm contained in the source
        directory provides the data you need.</p><p>The output generated by the application using the topic map data
        provided should look like this (the topic identifiers will, of course,
        be different when you run the application, but the names should be the
        same):</p><pre class="programlisting">Removing existing topic map...
Importing XTM file kings_and_queens.xtm. Please wait...
XTM import was successful!
Children of William I:
  2612 - Adela
  2566 - Robert Curthose, Duke Of Normandy
  2598 - William II
  2596 - Henry I

William I:
  2612 - Adela
    2606 - Stephen
  2596 - Henry I
    2592 - Matilda, Daugher Of Henry I
      2580 - Henry II
        2582 - John
          2676 -
        2602 - Richard I
    2600 - William, Son of Henry I
  2566 - Robert Curthose, Duke Of Normandy
  2598 - William II</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e780"></a>APIExample5: Using The ApplicationOntology Cache</h2></div></div></div><p>You will have seen from the previous section, that coding TMRQL
      statements can require quite a lot of work in locating the topics that
      are input parameters into each query. You either end up writing code to
      find the topics using the Index API or you need to write long TMRQL
      queries that use sub-selects to find the topics. Most of the time, these
      topics are related to the system of topic, association, role and
      occurrence types in your topic map data and should be assigned URI
      subject identifiers to enable them to be found in the database. The
      ApplicationOntology object gives you a convenient API for managing these
      topics as well as an efficient local cache that can both improve query
      performance and make TMRQL queries more readable. You can read more
      about the ApplicationOntology object in <a href="#ApplicationOntology" title="The ApplicationOntology Object">the section called &#8220;The ApplicationOntology Object&#8221;</a>. For the purposes of this section, you
      can think of the ApplicationOntology as a special form of cache in which
      short string keys can be used to retrieve full ITopic instances. The
      keys used can be directly tied to the URIs assigned to the topics in the
      topic map.</p><p>APIExample5 is a rewrite of APIExample4 using the
      ApplicationOntology object. The main order of processing is now:</p><div class="orderedlist"><ol type="1"><li><p>Import the XTM source file.</p></li><li><p>Initialise the ApplicationOntology cache.</p></li><li><p>Perform the two queries as before but using the
          ApplicationOntology object to find the input topics.</p></li></ol></div><p>The initialisation of the ApplicationOntology object is performed
      in the method GetApplicationOntology(). The code for this method is
      shown below.</p><pre class="programlisting">private ApplicationOntology GetApplicationOntology(ITopicMap tm)
{
  // Retrieve the inner ontology from the app settings file.
  ApplicationOntology innerOnt = System.Configuration.ConfigurationSettings.GetConfig("ontology") as ApplicationOntology;
  innerOnt.AddTopicMap(tm);
  // Create an outer ontology with the inner ontology nested.
  ApplicationOntology outerOnt = new ApplicationOntology(innerOnt);
  outerOnt.AddPrefix("monarchs", "http://www.example.com/psi/uk-monarchs/");
  outerOnt.AddTopicMap(tm);
  return outerOnt;
}</pre><p>This code shows three important features of the
      ApplicationOntology object. Firstly an ApplicationOntology object can be
      constructed from the configuration settings for an application. This
      allows users to specify their ontology mappings using XML in the
      application's .config or Web.config file. Secondly, an
      ApplicationOntology can be intialised purely in code - this allows you
      to write code that uses specific mappings regardless of configuration
      file settings. Finally, ApplicationOntology objects can be nested one
      inside another - if the outer object cannot map an key to an ITopic
      instance, it passes the request to its nested ApplicationOntology object
      (which can in turn pass the request to its nested ApplicationOntology
      object and so on).</p><p>This code also shows how much of the cache mapping of the
      ApplicationOntology object works. You do not need to specify a cache key
      for every topic (although you can if you want to). Instead you declare a
      prefix string and the URI prefix that it maps to. You can then look up a
      topic using the prefix string followed by a colon and the rest of the
      URI. The ApplicationOntology will then expand the prefix and rest of URI
      into a full URI and search for a topic with that expanded URI as its
      subject identiifer. So in the code example above we add a prefix string
      "monarchs" for the URI prefix "http://www.example.com/psi/uk-monarchs/"
      - we can then find the topic for William I using the cache key
      "monarchs:william-i" which gets expanded to
      "http://www.example.com/psi/uk-monarchs/william-i" and locates the topic
      with that URI as a subject identifier. Once an ApplicationOntology
      object performs this expansion and finds a match, it then caches the
      direct topic reference, meaning that all future requests for the same
      item can be resolved without a look-up in the database. When you use the
      same topics time after time, this can provide a significant performance
      boost.</p><p>Looking up a topic using a cache key is simple in code - the
      ApplicationOntology acts like a normal .NET dictionary, returning ITopic
      instances from string keys, so you can write look-up code like
      this:</p><pre class="programlisting">ITopic william = ontology["monarchs:william-i"];</pre><p>However, the ApplicationOntology object also provides a method
      that assists in writing TMRQL statements by pre-processing them to
      replace cache key strings in curly braces with the object ID of the
      topic that is indexed against that cache key. This is shown in the
      QueryChildren() method by the following code:</p><pre class="programlisting">private void QueryChildren(ITopicMap tm, ApplicationOntology ontology) 
{
  string query = 
    "SELECT r2p, dbo.tm_displayName(r2p) FROM tm_assoc2 WHERE" +
    "  topicmap = " + tm.ObjectID + " AND " +
    "  r1p={william} AND association_type={family:child-of} AND r1t={family:parent}";
  query = ontology.ReplaceReferences(query);
  try 
  {
    ITMCoreDataReader dr = tm.TopicMapSystem.ExecuteQuery(query);
  ...</pre><p>The cache keys are written in the TMRQL statement surrounded by
      curly braces ({}). In this example the ApplicationOntology has been
      configured withs a direct mapping for the cache key "william" to the
      subject identifier "http://www.example.com/psi/uk-monarchs/william-i" as
      well as a prefix mapping for the string "family" to the URI prefix
      "http://www.example.com/psi/family/". The call to the
      ReplaceReferences() method of the ApplicationOntology object replaces
      these cache keys with the object identifiers of the topics "William I",
      "child-of" and "parent" respectively.</p><p>As you can see by comparing with the code from APIExample4, the
      ApplicationOntology object makes queries easier to write and to read
      and, because you avoid the need to do index lookups multiple times or to
      make use of SQL sub-selects in your queries, your code will execute
      faster too.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e819"></a>Running The Example</h3></div></div></div><p>This example program requires a single command line argument
        that specifies the path to the XTM file that defines the data to be
        queried. The example file kings_and_queens.xtm contained in the source
        directory provides the data you need.</p><p>The output generated by the application using the topic map data
        provided should be the same as for APIExample4.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e826"></a>Chapter&nbsp;4.&nbsp;TMCore API Overview</h2></div></div></div><p>The TMCore API is divided into the following namespaces:</p><div class="variablelist"><dl><dt><span class="term">NetworkedPlanet.TMAPI</span></dt><dd><p>Provides the interfaces that model the TMCore topic map system
          and the topic map data model supported by TMCore. These interfaces
          are described in more detail in <a href="#core-api" title="Chapter&nbsp;5.&nbsp;Core API">Chapter&nbsp;5, <i>Core API</i></a>.</p></dd><dt><span class="term">NetworkedPlanet.TMAPI.Index</span></dt><dd><p>Provides the interfaces for the principal object indexes
          supported by the TMCore API. The NetworkedPlanet.Index namespace
          contains only the base interface that defines operations common to
          all indexes. The sub-namespace NetworkedPlanet.Index.Core that
          contains the individual index interface definitions. See <a href="#indexes" title="Chapter&nbsp;6.&nbsp;Indexes">Chapter&nbsp;6, <i>Indexes</i></a> for more information.</p></dd><dt><span class="term">NetworkedPlanet.TMAPI.Query</span></dt><dd><p>Provides interfaces for managing the results of executing a
          query against the TMCore topic map system. The query interfaces are
          described in <a href="#querying" title="Chapter&nbsp;9.&nbsp;Querying">Chapter&nbsp;9, <i>Querying</i></a>.</p></dd><dt><span class="term">NetworkedPlanet.TMCore.Utils</span></dt><dd><p>Contains some useful utilities for accessing and manipulating
          topic maps. These utilities are described in more detail in <a href="#utilities" title="Chapter&nbsp;8.&nbsp;TMCore System Utilities">Chapter&nbsp;8, <i>TMCore System Utilities</i></a>.</p></dd><dt><span class="term">NetworkedPlanet.TMSyntax</span></dt><dd><p>Contains interfaces that model processors for importing and
          exporting topic maps from TMCore. For more information, please refer
          to <a href="#tmsyntax" title="Chapter&nbsp;7.&nbsp;Importing and Exporting XTM Files">Chapter&nbsp;7, <i>Importing and Exporting XTM Files</i></a>.</p></dd><dt><span class="term">NetworkedPlanet.Npcl</span></dt><dd><p>Contains the APIs for the Networked Planet Constraint Language
          (NPCL). See <a href="#npcl-overview" title="Chapter&nbsp;11.&nbsp;The NetworkedPlanet Constraint Language (NPCL)">Chapter&nbsp;11, <i>The NetworkedPlanet Constraint Language (NPCL)</i></a> and <a href="#npcl-api" title="Chapter&nbsp;12.&nbsp;The NPCL Constraints API">Chapter&nbsp;12, <i>The NPCL Constraints API</i></a> for more details.</p></dd></dl></div><p>The rest of this document is intended to give you an overview of all
    of the facilities of the various APIs rather than to give a complete list
    of every interface, class, method and property. For full detail on all
    interfaces, classes, methods and properties defined by the API, please
    refer to the HTML Help documentation contained in the file
    <code class="filename">doc\tmcore-api.chm</code>.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="core-api"></a>Chapter&nbsp;5.&nbsp;Core API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#TopicMapSystem_TopicMapSystemFactory">ITopicMapSystem and TopicMapSystemFactory</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1044">Other ITopicMapSystem Methods</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1085">ITopicMapObject And Its Derived Interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1093">Containment and Object Creation and Removal</a></span></dt><dt><span class="section"><a href="#d0e1214">ITopicMapObject</a></span></dt><dt><span class="section"><a href="#d0e1268">ITopicMap</a></span></dt><dt><span class="section"><a href="#d0e1328">Mapping TMCore Interfaces And Properties to XTM Elements And
        Attribute</a></span></dt><dt><span class="section"><a href="#d0e1497">Concurrent Modification</a></span></dt><dt><span class="section"><a href="#d0e1551">Topic Merging</a></span></dt></dl></dd></dl></div><p>This package contains interfaces and classes that support the
    fundamentals of TMCore system programming:</p><div class="orderedlist"><ol type="1"><li><p>Configuring and accessing a TMCore system. This is supported by
        the class TopicMapSystemFactory and the interface
        ITopicMapSystem.</p></li><li><p>A data model for topic maps and all of the objects found in
        topic maps, using the interface ITopicMapObject and all of its derived
        interfaces.</p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TopicMapSystem_TopicMapSystemFactory"></a>ITopicMapSystem and TopicMapSystemFactory</h2></div></div></div><p>The interface
      <code class="interfacename">NetworkedPlanet.TMAPI.ITopicMapSystem</code>
      represents a connection to a TMCore system. In the TMCore system, the
      topic maps that it manages are each assigned a unique identifier string
      specifed by the <span class="property">Name</span> property of the
      <code class="interfacename">ITopicMap</code> instance. The property
      <code class="methodname">ITopicMapSystem.TopicMapNames</code> returns a
      read-only <code class="interfacename">IList</code> containing the
      <span class="property">Name</span> property value of all topic maps that are
      currently accesible through the
      <code class="interfacename">ITopicMapSystem</code>. The
      <code class="interfacename">ITopicMapSystem</code> method
      <code class="methodname">GetTopicMap(String)</code>is an access method to
      retrieve an <code class="interfacename">ITopicMap</code> from the
      <code class="interfacename">ITopicMapSystem</code> using the value of its
      <span class="property">Name</span> property as a key.</p><p>In addition, the <code class="interfacename">ITopicMapSystem</code>
      interface allows you to create a new topic map in the TMCore system. To
      create a new topic map, you will need to specify the unqiue name under
      which the topic map should be stored. If you specify a name which is
      already in use, a <code class="classname">TopicMapExists</code> exception will
      be thrown.</p><p>An <code class="interfacename">ITopicMapSystem</code> instance cannot
      be created directly, the TMCore API does not publicly expose a class
      that implements this interface. Instead you must use the class
      <code class="classname">NetworkedPlanet.TMAPI.TopicMapSystemFactory</code> to
      configure and initialise an
      <code class="interfacename">ITopicMapSystem</code> instance. The
      configuration required for an
      <code class="interfacename">ITopicMapSystem</code> is specified as a
      collection of name/value pairs as shown in the following table:</p><div class="table"><a name="d0e962"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;ITopicMapSystem Configuration Properties</b></p><table summary="ITopicMapSystem Configuration Properties" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Property Name</td><td>Required?</td><td>Description</td></tr><tr><td>networkedplanet.tmcore.dbconnect</td><td>YES</td><td>The database connect string used to access the SQLServer
              instance that holds the TMCore system tables.</td></tr><tr><td>networkedplanet.tmcore.commandtimeout</td><td>NO</td><td>The number of seconds that a TMRQL command executed via
              <code class="methodname">ITopicMapSystem.ExecuteQuery</code> or
              <code class="methodname">ITopicMapSystem.ExecuteQueries</code> will
              time out after. Default value is 15.</td></tr></tbody></table></div><p>The <code class="classname">TopicMapSystemFactory</code> class provides an
      overloaded method <code class="methodname">GetTopicMapSystem()</code> that
      accepts this configuration information in a number of different ways.
      The method <code class="methodname">GetTopicMapSystem()</code> with no
      arguments will configure the
      <code class="interfacename">ITopicMapSystem</code> instance using the local
      application configuration file. This file is an XML file that is named
      either <code class="filename">Web.config</code> for web applications or
      <code class="filename"><em class="replaceable"><code>AppName</code></em>.config</code> for
      applications (e.g. <code class="filename">MyApp.exe.config</code> for an
      application called <code class="filename">MyApp.exe</code>). The configuration
      information must go in the <code class="sgmltag-element">&lt;appSettings&gt;</code>
      element of the config file. More information about the appSettings and
      configuration files can be found <a href="http://msdn.microsoft.com/library/en-us/cpgenref/html/gngrfappsettingselement.asp" target="_top">here
      on the Microsoft MSDN site</a>. An example of an application
      configuration file is shown below:</p><div class="example"><a name="d0e1028"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;A simple .config file for a TMCore Application</b></p><pre class="programlisting">&lt;?xml version="1.0" encocing="utf-8" ?&gt;
&lt;configuration&gt;
  ...
  &lt;appSettings&gt;
    &lt;add key="networkedplanet.tmcore.dbconnect"
         value="Data Source=localhost;Integrated Security=SSPI; Initial Catalog=topicmap" /&gt;
    ...
  &lt;/appSettings&gt;
  ...
&lt;/configuration&gt;
</pre></div><p>If you wish to retrieve the configuration information in some
      other way, or wish to include a hard-coded set of configuration
      parameters in your application, you can instead use the method
      <code class="methodname">GetTopicMapSystem(NameValueCollection)</code>. The
      <code class="classname">NameValueCollection</code> parameter contains the
      property/value pairs to configure the
      <code class="interfacename">ITopicMapSystem</code> that will be
      returned.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1044"></a>Other ITopicMapSystem Methods</h3></div></div></div><p>In addition to enabling the creation and retrieval of topic
        maps, <code class="interfacename">ITopicMapSystem</code> interface
        provides methods and properties access to some TMCore system
        utilities.</p><p>The method <code class="methodname">GetXTMProcessor()</code> retrieves
        an object implementing the IXTMProcessor interface that allows topic
        map data to be imported into or exported from the TMCore system using
        the standard XML Topic Maps (XTM) syntax. Import and export of XTM
        files is covered in more detail in <a href="#tmsyntax" title="Chapter&nbsp;7.&nbsp;Importing and Exporting XTM Files">Chapter&nbsp;7, <i>Importing and Exporting XTM Files</i></a>.</p><p>The method <code class="methodname">ExecuteQuery()</code> is used to
        execute an SQL query against the relational topic map data model
        exposed by the TMCore system. This method returns an
        <code class="interfacename">ITMCoreDataReader</code> instance. The
        relational topic map model, querying and the
        <code class="interfacename">ITMCoreDataReader</code> interface are dealt
        with in <a href="#querying" title="Chapter&nbsp;9.&nbsp;Querying">Chapter&nbsp;9, <i>Querying</i></a>.</p><p>The property <span class="property">ChangeNotifier</span> returns an
        instance of the <code class="interfacename">IChangeNotifier</code>
        interface which can be used to monitor the TMCore system for
        modifications made to topics and associations by any clients connected
        to the system. The <code class="interfacename">IChangeNotifier</code>
        interface is described in more detail in <a href="#change-notification" title="Change Notification">the section called &#8220;Change Notification&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1085"></a>ITopicMapObject And Its Derived Interfaces</h2></div></div></div><p>Each of the types of item defined by the topic maps data model is
      represented in the TMCore API by an interface. The names of the
      interfaces may be slightly unfamiliar to users of the XTM syntax because
      they are based on a more abstract model of a topic map called the "Topic
      Maps Data Model" (TMDM). This model is currently under development as
      part of the next version of ISO 13250 and so the TMCore interfaces cover
      both this model and a slightly modified version of it for XTM 1.0 topic
      maps. For more information about TMDM see <a href="http://www.isotopicmaps.org/sam/sam-model/" target="_top">the ISO Topic Maps
      website</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1093"></a>Containment and Object Creation and Removal</h3></div></div></div><p>Understanding the TMCore containment hierarchy is the key to
        working with the TMCore API. In a TMCore system, every object is
        considered to be contained within one (and only one) other object. The
        hierarchy is based on types, so all
        <code class="interfacename">ITopic</code> instances are contained within
        an <code class="interfacename">ITopicMap</code> instance; all
        <code class="interfacename">IOccurrence</code> instances are contained
        within an <code class="interfacename">ITopic</code> instance and so on.
        The containment hieararchy is shown below:</p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="interfacename">ITopicMapSystem</code>
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  <code class="interfacename">ITopicMap</code>
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                      <code class="interfacename">IAssociation</code>
                    </p><div class="itemizedlist"><ul type="circle"><li><p>
                          <code class="interfacename">IAssociationRole</code>
                        </p></li></ul></div></li><li><p>
                      <code class="interfacename">ITopic</code>
                    </p><div class="itemizedlist"><ul type="circle"><li><p>
                          <code class="interfacename">IOccurrence</code>
                        </p></li><li><p>
                          <code class="interfacename">ITopicName</code>
                        </p><div class="itemizedlist"><ul type="disc"><li><p>
                              <code class="interfacename">IVariant</code>
                            </p></li></ul></div></li></ul></div></li></ul></div></li></ul></div></li></ul></div><p>The containment hierarchy is important in three respects, object
        creation, object removal and commits to the TMCore system.</p><p>An object can only be created as a child of its parent in the
        containment hierarchy. This means that there are no public
        constructors for any of the TMCore interfaces, instead you must use
        the method <code class="methodname">CreateXXX()</code> on the parent object
        in the containment hierarchy where the XXX is replaced by the name of
        the type of object you wish to create. For example, to create a topic,
        call the method <code class="methodname">ITopicMap.CreateTopic()</code> on
        the <code class="interfacename">ITopicMap</code> instance that will
        contain the new topic. Some of the
        <code class="methodname">CreateXXX()</code> methods are overloaded to provide
        different ways of initialising the created object.</p><p>An object can never be detatched from its parent in the
        containment hiearchy. The only way to remove an object from its parent
        is to call the <code class="methodname">Remove()</code> method on the object
        itself. The <code class="methodname">Remove()</code> method not only removes
        the object from its parent, but also deletes it completely from the
        TMCore system.</p><p>Finally, when an object in the containment hierarchy is
        committed to the TMCore system using the
        <code class="methodname">Save()</code> method, changes to all of its children
        in the containment hierarchy are also committed in a single
        transaction. The <code class="methodname">Save()</code> method is provided on
        the <code class="interfacename">ITopicMap</code>,
        <code class="interfacename">IAssociation</code> and
        <code class="interfacename">ITopic</code> interfaces only, so to save a
        change to an <code class="interfacename">ITopicName</code> instance, you
        must call the <code class="methodname">Save()</code> method on the containing
        <code class="interfacename">ITopic</code> instance.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1214"></a>ITopicMapObject</h3></div></div></div><p>The <code class="interfacename">ITopicMapObject</code> interface is
        the base interface for all interfaces that represent items in a topic
        map and for the <code class="interfacename">ITopicMap</code> interface
        itself. The <code class="interfacename">ITopicMapObject</code> interface
        provides access to the <span class="property">SourceLocators</span> property.
        Source locators are identifiers for an
        <code class="interfacename">ITopicMapObject</code>. When an object is
        created as the result of importing an XTM file, a source locator is
        assigned to that object if the corresponding XTM element had an ID
        attribute value. The value is resolved to a complete URI relative to
        the URI of the XTM data source being parsed. For example if an XTM
        file is parsed from a source
        "http://www.example.com/topicmaps/example1.xtm" and that file contains
        an &lt;association&gt; element with the ID attribute "myAssoc", the
        resulting IAssociation instance will have a source locator with the
        value "http://www.example.com/topicmaps/example1.xtm#myAssoc". An
        <code class="interfacename">ITopicMapObject</code> can have any number of
        source locators, but it is an error for two different
        <code class="interfacename">ITopicMapObject</code> interfaces in the same
        topic map to have a common source locator. When an attempt is made to
        assign a source locator to any
        <code class="interfacename">ITopicMapObject</code> instance, the system
        will raise a <code class="classname">DuplicateSourceLocators</code> exception
        if there is another object in the same topic map with the same source
        locator value, UNLESS both objects are topics, in which case the
        topics will be merged.</p><p>The <span class="property">ObjectId</span> property is a read-only string
        which specifies the unique identifier assigned to the object by the
        TMCore system.</p><p>The <span class="property">TopicMap</span> property returns the
        <code class="interfacename">ITopicMap</code> instance that this
        <code class="interfacename">ITopicMapObject</code> instance is contained
        in. If the object is itself an
        <code class="interfacename">ITopicMap</code>, this property returns the
        <code class="interfacename">ITopicMap</code> object it is invoked
        on.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1268"></a>ITopicMap</h3></div></div></div><p>The <code class="interfacename">ITopicMap</code> interface provides
        access to the basic properties of a topic map, including the topics
        and associations that it contains and the indexes it provides. This
        interface also defines a number of special methods.</p><p>The <span class="property">Topics</span> and
        <span class="property">Associations</span> properties are read-only properties
        which yield a read-only list of all topics or associations in the
        topic map.</p><p>The properties with names that end "...Index" provide direct
        access to the object indexes maintained by TMCore for the topic map.
        These indexes allow lookup of objects in the topic map by a variety of
        different properties of those objects. The indexes are covered in
        greater detail in <a href="#basicindexes" title="The Core Indexes">the section called &#8220;The Core Indexes&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1288"></a>Merging Topic Maps with the MergeIn() method</h4></div></div></div><p>The method
          <code class="methodname">ITopicMap.MergeIn(ITopicMap)</code> can be used to
          merge one <code class="interfacename">ITopicMap</code> instance into
          another. The <code class="interfacename">ITopicMap</code> on which the
          method is invoked will be modified, gaining copies of all of the
          topics and associations of the other
          <code class="interfacename">ITopicMap</code> (with any merging required
          also performed). The other <code class="interfacename">ITopicMap</code>
          will not be modified in anyway by this method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1308"></a>Retrieving Objects by Their Database ID</h4></div></div></div><p>Every object in a TMCore database has a unique integer
          identifier. The identifier is persistent across multiple sessions
          and is only removed from the database as the result of a Remove()
          method call or topic merging. The
          <code class="interfacename">ITopicMap</code> interface provides two
          convenience methods <code class="methodname">GetTopicByID(int id)</code>
          and <code class="methodname">GetAssociationByID(int id)</code> to retrieve
          <code class="interfacename">ITopic</code> and
          <code class="interfacename">IAssociation</code> instances directly by
          this database ID.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1328"></a>Mapping TMCore Interfaces And Properties to XTM Elements And
        Attribute</h3></div></div></div><p>The following list shows the mappings that are made between XTM
        elements and TMCore interfaces and properties.</p><div class="itemizedlist"><ul type="disc"><li><p>Whenever a <code class="sgmltag-element">subjectIndicatorRef</code> element is
            encountered where its parent is not a
            <code class="sgmltag-element">subjectIdentity</code> element, it is mapped to a
            Topic with the <code class="sgmltag-element">subjectIndicatorRef</code> address as
            one of its <span class="property">SubjectIdentifiers</span> property values
            or one of its <span class="property">SourceLocators</span> property
            values.</p></li><li><p>The <code class="interfacename">ITopicName</code> interface and
            <span class="property">TopicNames</span> property of the
            <code class="interfacename">ITopic</code> interface map to the XTM
            <code class="sgmltag-element">baseName</code> element.</p></li><li><p>The <span class="property">SubjectLocators</span> property of
            <code class="interfacename">Topic</code> maps to the
            <code class="sgmltag-element">subjectIdentity/resourceRef</code> element.</p><div class="note"><h3 class="title">Note</h3><p>Under the XTM 1.0 data model, a topic can only have one
              subject locator. However the proposed XTM 1.1 data model extends
              this to allow a topic to have multiple subject locators. In the
              TMCore API, the property is represented as an IList of strings
              to support this future extension.</p></div></li><li><p>The <span class="property">SubjectIdentifiers</span> property of
            <code class="interfacename">ITopic</code> maps to the
            <code class="sgmltag-element">subjectIdentity/subjectIndicatorRef</code>
            elements.</p></li><li><p>Each <code class="interfacename">IAssociationRole</code>
            instance maps to one combination of <code class="sgmltag-element">roleSpec</code>
            and <code class="sgmltag-element">topicRef</code> or
            <code class="sgmltag-element">subjectIndicatorRef</code> inside an
            <code class="sgmltag-element">association/member</code> element. The
            <code class="sgmltag-element">member</code> element actually allows multiple
            <code class="sgmltag-element">topicRef</code> or
            <code class="sgmltag-element">subjectIndicatorRef</code> elements to appear after
            the <code class="sgmltag-element">roleSpec</code>, however in TMCore system, these
            are "flattened" into a list of pairs of ITopic instances. For
            example given an association like this in XTM:</p><pre class="programlisting">
&lt;association&gt;
  &lt;instanceOf&gt;&lt;topicRef xlink:href="#works-for"/&gt;&lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;&lt;topicRef xlink:href="#employer"/&gt;&lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#boulder-rock-company"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;&lt;topicRef xlink:href="#employee"/&gt;&lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#fred"/&gt;
    &lt;topicRef xlink:href="#barney"/&gt;
  &lt;/member&gt;
&lt;/association&gt;
	    </pre><p>The resulting TMAPI representation would be an Association
            instance containing three AssociationRole instances (in its
            <span class="property">associationRoles</span> property).</p></li><li><p>Nested <code class="sgmltag-element">variant</code> elements in XTM syntax are
            "flattened" in the TMCore API to a single level of
            <code class="interfacename">IVariant</code> children of the
            <code class="interfacename">ITopicName</code> instance. The
            <code class="interfacename">IVariant</code> instances have all the
            parameters specified on the <code class="sgmltag-element">variant</code> element
            itself plus all those specified on its ancestor
            <code class="sgmltag-element">variant</code> elements.</p></li><li><p>The list of parameters for a <code class="sgmltag-element">variant</code> can
            be found in the <span class="property">Scope</span> property of the
            <code class="interfacename">IScopedObjects</code> interface (which is
            a superclass of the IVariant interface).</p></li><li><p>If the content of an <code class="sgmltag-element">occurrence</code> or
            <code class="sgmltag-element">variant</code> is a <code class="sgmltag-element">resourceData</code>
            element, then the string content of the
            <code class="sgmltag-element">resourceData</code> element can be retrieved from the
            <span class="property">Value</span> property of the
            <code class="interfacename">IOccurrence</code> or
            <code class="interfacename">IVariant</code> interface. If the content
            is a <code class="sgmltag-element">resourceRef</code> element, then the string which
            represents the address pointed to be the
            <code class="sgmltag-element">resourceRef</code> link can be retrieved from the
            <span class="property">Resource</span> property instead.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1497"></a>Concurrent Modification</h3></div></div></div><p>The TMCore API does not provide any explicit transaction control
        methods. Instead, the TMCore system allows concurrent access using an
        optimistic locking strategy. Under this strategy data is loaded from
        the TMCore database without locking the rows in the database (allowing
        any other application to concurrently access the data). Only when the
        data is saved back to the database, is the database checked to ensure
        that no other application modified the data in the intervening time.
        If a modification did take place (known as a concurrent modification),
        a <code class="exceptionname">ConcurrentModificationException</code> is
        raised and the updates that were attempted will be aborted. When a
        call to <code class="methodname">ITopic.Save()</code>,
        <code class="methodname">IAssociation.Save()</code> or
        <code class="methodname">ITopicMap.Save()</code> is made, all changes to the
        object on which the <code class="methodname">Save()</code> method was invoked
        and all contained objects will be committed to the database in a
        single transaction. This means that a call to
        <code class="methodname">Save()</code> will either succeed completely or fail
        without modifying the database.</p><p>To minimize the chances of and the impact of concurrent
        modification, it is strongly recommended that you tailor the commit
        strategy for your application to the expected write patterns against
        the topic map. If you anticipate frequent writes from multiple
        separate threads, then try to keep the number of changes between calls
        to the <code class="methodname">Save()</code> method as small as possible.
        This strategy will maximise the interleaving between applications and
        minimize the amount of work you need to redo in the case of a
        <code class="exceptionname">ConcurrentModificationException</code>. If you
        anticipate only infrequent writes or if you can isolate writes to one
        thread or if you can isolate writer threads in a way that would
        prevent them from writing the same objects in the topic map, then you
        can afford to make more updates to the topic map between calls to
        <code class="methodname">Save()</code>.</p><p>From TMCore05 SP2, the <code class="interfacename">ITopic</code> and
        <code class="interfacename">IAssociation</code> interfaces both support a
        method named <code class="methodname">Reload()</code>. This method can be
        used to update an ITopic or IAssociation instance from the database,
        overwriting any local modifications with the most recent version of
        the object from the persistent store. To recover from a
        <code class="exceptionname">ConcurrentModificationException</code>
        therefore, you must first invoke the <code class="methodname">Reload()</code>
        method on the locally modified object, then reapply any local
        modifications and finally invoke the <code class="methodname">Save()</code>
        method to save your changes to the persistent store.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1551"></a>Topic Merging</h3></div></div></div><p>Topic merging is handled automatically by TMCore under the
        following circumstances:</p><div class="itemizedlist"><ul type="disc"><li><p>Two topics have at least one common string value in their
            SubjectLocators property.</p></li><li><p>Two topics have at least one common string value in their
            SubjectIdentifiers property.</p></li><li><p>Two topics have at least one common string value in their
            for the SourceLocators property.</p></li><li><p>One topic has a SubjectIdentifier property value that is in
            the SourceLocators property of another topic.</p></li></ul></div><p>The need for merging is detected only when a topic is saved to
        the TMCore system. When merging takes place, the topic which was saved
        and whose modification is the cause of the merge receives all of the
        names and occurrences of the other topic and replaces that topic in
        all typing and scoping relationships. The other topic is then removed
        from the TMCore system. Any local reference to the removed topic is
        mapped through to the remaining topic automatically, but this only
        happens in the thread that caused the merging to take place. For all
        other threads, the changes will appear just as if one topic was
        modified and the other deleted from the system - any attempt to save
        changes to either of these topics after the merge occurred will result
        in a ConcurrentModificationException (assuming that the topics were
        initially retrieved from the system prior to the merge taking
        place).</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="indexes"></a>Chapter&nbsp;6.&nbsp;Indexes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#IndexAPI">The IIndex Interface</a></span></dt><dt><span class="section"><a href="#basicindexes">The Core Indexes</a></span></dt></dl></div><p>The namespace NetworkedPlanet.TMAPI.Index contains only a single
    interface, IIndex which defines the basic methods supported by all of the
    indexes provided from an ITopicMap instance. The namespace
    NetworkedPlanet.TMAPI.Index.Core contains interfaces which extend IIndex
    to provide methods for accessing indexed information about the objects in
    a topic map.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IndexAPI"></a>The IIndex Interface</h2></div></div></div><p>The interface <code class="interfacename">IIndex</code> defines a
      generic interface for an index over the data in a single TopicMap
      instance. The <code class="interfacename">IIndex</code> interface provides
      methods for opening and closing an index; and for determining whether an
      index is currently open or closed.</p><p>The methods <code class="methodname">IIndex.Open()</code> and
      <code class="methodname">Close()</code> are used to modify the open state of
      the index. The property <span class="property">IsOpen</span> is a boolean value
      which is true when the index is open. Calling any index retrieval
      methods on an index which is not open will result in an exception being
      thrown.</p><div class="note"><h3 class="title">Note</h3><p>The IIndex interface is defined for future extension to
        implementations which may require local resources to be consumed when
        an index is open. The SQLServer implementation of the TMCore API does
        not consume any local resources. For the SQLServer implementation, all
        indexes are automatically created as open and the
        <code class="methodname">Close()</code> method has no effect, hence the value
        of the <span class="property">IsOpen</span> property is always true.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basicindexes"></a>The Core Indexes</h2></div></div></div><p>The namespace NetworkedPlanet.TMAPI.Index.Core defines a
      collection of index interfaces all of which are derived from
      <code class="interfacename">IIndex</code>. Each of these index interface
      provides additional methods for accessing indexed information about one
      of the types of object in a topic map. The following table summarises
      the core index interfaces and the indexes they provide access to.</p><div class="table"><a name="d0e1615"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;TMAPI Core Indexes</b></p><table summary="TMAPI Core Indexes" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col></colgroup><thead><tr><th>
                <p>Index Interface</p>
              </th><th>
                <p>Functionality</p>
              </th></tr></thead><tbody><tr><td>
                <p>
                  <code class="interfacename">IAssociationRolesIndex</code>
                </p>
              </td><td>
                <p>Provides a list of all ITopics which define the type of
                one or more IAssociationRoles and an index of
                IAssociationRoles by their type.</p>
              </td></tr><tr><td>
                <p>
                  <code class="interfacename">IAssociationsIndex</code>
                </p>
              </td><td>
                <p>Provides a list of all ITopics which define the type of
                one or more IAssociations and an index of IAssociations by
                their type.</p>
              </td></tr><tr><td>
                <p>
                  <code class="interfacename">IOccurrencesIndex</code>
                </p>
              </td><td>Provides a list of all ITopics which define the type of
              one or more IOccurrences; an index of IOccurrences by their
              type; an index of IOccurrences by their
              <span class="property">Resource</span> property; and an index of
              IOccurrences by their <span class="property">Value</span>
              property.</td></tr><tr><td>
                <p>
                  <code class="interfacename">IScopedObjectsIndex</code>
                </p>
              </td><td>Provides a list of all ITopics which are part of the
              scope of one or more IScopedObjects (IAssociations,
              IOccurrences, ITopicNames and IVariants); and an index of
              IScopedObjects by their scoping topics. This index can be
              queried for all IScopedObjects with a specified ITopic as a
              scoping topic; all IScopedObjects with a specified collection of
              ITopics as part of their list of scoping topics (matching all
              the specified Topics) or all IScopedObjects with at least one of
              a specified collection of ITopics as one of their scoping
              topics.</td></tr><tr><td>
                <p>
                  <code class="interfacename">ITopicMapObjectsIndex</code>
                </p>
              </td><td>
                <p>Provides an index of all ITopicMapObjects by their
                <span class="property">SourceLocators</span> property.</p>
              </td></tr><tr><td>
                <p>
                  <code class="interfacename">ITopicNamesIndex</code>
                </p>
              </td><td>
                <p>Provides an index of ITopicNames by their
                <span class="property">Value</span> property.</p>
              </td></tr><tr><td>
                <p>
                  <code class="interfacename">ITopicsIndex</code>
                </p>
              </td><td>
                <p>Provides a list of all ITopics which define the type of
                one or more ITopics; an index of ITopics by their
                <span class="property">SubjectIdentifiers</span>; an index of ITopics
                by their <span class="property">SubjectLocators</span> and an index of
                ITopics by their <span class="property">Types</span>. The index of
                ITopics by <span class="property">Types</span> allows you to retrieve
                either all ITopics with a specified ITopic in the
                <span class="property">Types</span> property; all ITopics with a
                specified collection of ITopics in the
                <span class="property">Types</span> property; or all ITopics with any
                one of a specified collection of ITopics in the
                <span class="property">Types</span> property.</p>
              </td></tr><tr><td>
                <p>
                  <code class="interfacename">IVariantsIndex</code>
                </p>
              </td><td>Provides an index of IVariants by their
              <span class="property">Resource</span> property and an index of IVariants
              by their <span class="property">Value</span> property.</td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tmsyntax"></a>Chapter&nbsp;7.&nbsp;Importing and Exporting XTM Files</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e1782">ImportXTM()</a></span></dt><dt><span class="section"><a href="#d0e1931">ExportXTM()</a></span></dt></dl></div><p>The namespace NetworkedPlanet.TMSyntax contains a single interface
    <code class="interfacename">IXTMProcessor</code> which provides methods for
    the import and export of topic map data in XTM syntax. XTM data can be
    imported to create a new topic map or to be merged into an existing topic
    map.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1782"></a>ImportXTM()</h2></div></div></div><p>This method allows topic map data to be imported from any stream
      into either an existing topic map or a new topic map within the TMCore
      system. The signature of the method is :</p><code class="methodsynopsis"><span class="type">NetworkedPlanet.TMAPI.ITopicMap&nbsp;</span><span class="methodname">ImportXTM</span>(<span class="methodparam"><span class="type">System.IO.Stream&nbsp;</span><span class="parameter">inputStream</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">System.Uri&nbsp;</span><span class="parameter">sourceLocator</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">string&nbsp;</span><span class="parameter">name</span></span>);</code><p>The XTM data is read from the stream
      <em class="parameter"><code>inputStream</code></em>. This stream may be from a local
      file, from an HTTP or FTP connection or from any other data source that
      supports the <code class="interfacename">System.IO.Stream</code>
      interface.</p><p>The second parameter, <em class="parameter"><code>sourceLocator</code></em>,
      specifies the URI address that is used for the resolution of any
      relative links found in the XTM data. This parameter has a number of
      effects on the addresses imported into the TMCore system:</p><div class="orderedlist"><ol type="1"><li><p>The <em class="parameter"><code>sourceLocator</code></em> parameter value plus
          the value of the <code class="sgmltag-element">id</code> attribute of the
          <code class="sgmltag-element">topicMap</code> element (if any) will be added to the
          <span class="property">SourceLocators</span> property of the
          <code class="interfacename">ITopicMap</code> instance into which the
          data is read. If the <code class="sgmltag-element">topicMap</code> element has an
          <code class="sgmltag-element">id</code> attribute value, then the source locator added
          will have a trailing # with the <code class="sgmltag-element">id</code> attribute
          value, otherwise only the complete document path part of the URI
          will be used.</p><p>e.g. If the <em class="parameter"><code>sourceLocator</code></em> parameter is
          "http://www.example.com/topicmaps/mymap.xtm" and the id attribute of
          the <code class="sgmltag-element">topicMap</code> element is "tm", then the value of
          the locator added to the <span class="property">SourceLocators</span>
          property will be
          "http://www.example.com/topicmaps/mymap.xtm#tm".</p><div class="note"><h3 class="title">Note</h3><p>If the <em class="parameter"><code>sourceLocator</code></em> parameter has
            fragment and/or query parts such as
            "http://www.example.com/topicmaps/maps.asp?param=mymap", then
            these will be removed from the locator before adding the fragment
            id (if any) for the <code class="sgmltag-element">topicMap</code> element.</p></div></li><li><p>Any relative references in <code class="sgmltag-element">resourceRef</code>
          elements will be resolved against the
          <em class="parameter"><code>sourceLocator</code></em> parameter value. This can be
          useful when you want to import from a local XTM file but have
          references to content resolve to a remote web server - as long as
          your XTM file has relative references, you can set the
          <em class="parameter"><code>sourceLocator</code></em> parameter so that the resulting
          references imported into TMCore resolve to the remote server.</p><p>For example if the topic map contains an
          <code class="sgmltag-element">&lt;occurrence&gt;</code> with a
          <code class="sgmltag-element">&lt;resourceRef&gt;</code> which references the relative
          URI "../docs/mydoc.html" and that topic map is imported with the
          <em class="parameter"><code>sourceLocator</code></em>
          "http://www.example.com/topicmaps/mymap.xtm", then the reference
          stored in TMCore will be the fully resolved reference
          "http://www.example.com/docs/mydoc.html", even if the source stream
          is read from a local file.</p></li><li><p>Any relative references to topics by a
          <code class="sgmltag-element">topicRef</code> element and any references to other
          topic maps to be merged by a <code class="sgmltag-element">mergeMap</code> element
          will be resolved against the <em class="parameter"><code>sourceLocator</code></em>
          parameter. The import process will always attempt to merge all maps
          referenced from a <code class="sgmltag-element">mergeMap</code> element and any
          external topic maps that contain topics referenced by a
          <code class="sgmltag-element">topicRef</code> element unless the address of the
          referenced topic map is already contained in the source locators for
          the current topic map (i.e. if that topic map was already imported
          and merged with the current topic map, it will not be imported
          again).</p></li></ol></div><p>The final parameter, <em class="parameter"><code>name</code></em>, specifies the
      name of the topic map into which the data will be imported. If this
      parameter is null, then the name will default to the string value of the
      <em class="parameter"><code>sourceLocator</code></em> parameter. If the name, after the
      default value has been applied if necessary, matches the name of a topic
      map that already exists in the TMCore system, then the data will be
      merged into the topic map with that name. If the name does not match any
      topic map already in the system, then a new topic map will be created.
      In either case, the method will return an
      <code class="interfacename">ITopicMap</code> instance that references the
      topic map that was modified or created as a result of the import.</p><div class="example"><a name="d0e1920"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Examples of Importing Into TMCore</b></p><pre class="programlisting">// Import from a local file into a new topic map named after the file:
File f = new File("C:\topicmaps\import.xtm");
Uri srcLoc = new Uri(f.FullName);
IXTMProcessor xtmp = m_topicMapSystem.GetXTMProcessor()
Stream input = f.OpenRead();
ITopicMap tm = xtmp.ImportXTM(input, srcLoc, srcLoc.ToString());
input.Close();
</pre><p>The code above reads XTM data from a local file into a topic map
        with a name based on the file name. In line [2] a new File object is
        created using the path to the file to be imported. In line [3], that
        full name is converted into URI syntax (e.g.
        file:///c/topicmaps/import.xtm). In line [5] a new IXTMProcessor is
        retrieved from the TopicMapSystem. The import is performed in line
        [6], using the stream opened in line [5], the Uri representation of
        the full file path for resolution of any relative paths; and the same
        Uri (cast to a string) as the name of the topic map to be populated.
        The return from this call will be an ITopicMap instance representing
        the topic map that received the XTM data. Finally, the input stream
        must be closed by the local code as the ImportXTM method will not
        modify the open state of a stream.</p><pre class="programlisting">// Import from a local file but resolve to remote references:
File f = new File("C:\topicmaps\import.xtm");
Uri srcLoc = new Uri("http://www.example.com/topicmaps/example1.xtm");
IXTMProcessor xtmp = m_topicMapSystem.GetXTMProcessor()
Stream input = f.OpenRead();
ITopicMap tm = xtmp.ImportXTM(input, srcLoc, srcLoc.ToString());
input.Close();
</pre><p>The code above also reads XTM data from a local file. However in
        this case, any relative URIs contained in the source XTM data will be
        resolved against the URI
        "http://www.example.com/topicmaps/example1.xtm".</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1931"></a>ExportXTM()</h2></div></div></div><p>The <code class="methodname">IXTMProcessor.ExportXTM()</code> method
      allows the content of a single topic map in the TMCore system to be
      written to a stream in XTM syntax. The method has the following
      signature:</p><code class="methodsynopsis"><span class="void">void&nbsp;</span><span class="methodname">ExportXTM</span>(<span class="methodparam"><span class="modifier">System.IO.Stream&nbsp;</span><span class="parameter">writer</span></span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="methodparam"><span class="type">NetworkedPlanet.TMAPI&nbsp;</span><span class="parameter">topicMap</span></span>);</code><p>The parameter <em class="parameter"><code>writer</code></em> specifies the output
      stream writer that is to receive the XTM data and the parameter
      <em class="parameter"><code>topicMap</code></em> specifies the
      <code class="interfacename">ITopicMap</code> instance whose content is to be
      exported.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="utilities"></a>Chapter&nbsp;8.&nbsp;TMCore System Utilities</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#change-notification">Change Notification</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2030">Database Considerations</a></span></dt></dl></dd><dt><span class="section"><a href="#ApplicationOntology">The ApplicationOntology Object</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2086">How the <code class="classname">ApplicationOntology</code> Works</a></span></dt><dt><span class="section"><a href="#d0e2113">Configuring The Application Ontology</a></span></dt><dt><span class="section"><a href="#d0e2225">Using the <code class="classname">ApplicationOntology</code></a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2285">Creating and Accessing Topic Hierarchies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2296">Creating a Hierarchy</a></span></dt><dt><span class="section"><a href="#d0e2493">Using The HierarchyManager API</a></span></dt><dt><span class="section"><a href="#d0e2575">Hierarchy Manager Example</a></span></dt></dl></dd></dl></div><p>The namespace NetworkedPlanet.TMCore.Utils provides a small set of
    utility classes for the TMCore system. With this release of TMCore, these
    utilities provide a mechanism for one thread to monitor the changes made
    in an <code class="interfacename">ITopicMapSystem</code> instance by all other
    threads; a class for handling short string references to topics; and a
    class for traversing hierarchies.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="change-notification"></a>Change Notification</h2></div></div></div><p>The change notification support of TMCore allows any thread to
      monitor the database for changes made by other threads to a specific
      topic map. The thread receives notification of the addition, removal or
      modification of all topics and associations in a topic map. Any changes
      to an object contained by a topic or association, including creation and
      removal are reported as a modification of the containing topic or
      association object.</p><p>The interface <code class="interfacename">IChangeNotifier</code>
      defines an abstract interface for this change notification system. This
      interface defines two events, <code class="classname">AssociationChange</code>
      and <code class="classname">TopicChange</code>. These two events are both of
      type <code class="classname">ObjectChangeNotification</code> which have the
      following signature:</p><pre class="programlisting">VB:
Public Delegate Sub ObjectChangeNotification( _
   ByVal objectID As String, _
   ByVal topicmapID As String, _
   ByVal changeType As ChangeType, _
   ByVal changeID As Integer _
)

C#:
public delegate void ObjectChangeNotification(
   string objectID,
   string topicmapID,
   ChangeType changeType,
   int changeID
);</pre><p>The <em class="parameter"><code>objectID</code></em> and
      <em class="parameter"><code>topicmapID</code></em> parameters specify the unique
      identifier of the object that was modified and of the topic map that
      contains the modified object. The <em class="parameter"><code>changeType</code></em>
      parameter is an enumerated type with the values CREATE, UPDATE and
      DELETE to notify creation, modification and removal events respectively.
      The <em class="parameter"><code>changeID</code></em> integer is a unique identifier for
      this change event. The identifier is a simple incrementing integer and
      so can be used to track the last event notified across multiple sessions
      (e.g. to determine if the listener missed an event for some
      reason).</p><p>The <code class="interfacename">IChangeNotifier</code> interface also
      defines methods for starting and stopping the polling of the database.
      The method <code class="methodname">StartPolling(long interval)</code> begins
      the polling of the database with an interval between polls specified in
      milliseconds by the parameter <em class="parameter"><code>interval</code></em>. When the
      startPolling() method is invoked, the first poll will be performed
      immediately, with subsequent polls ocurring each time the polling
      interval elapses. The method
      <code class="interfacename">StopPolling()</code> can be used to halt polling
      immediately. The method <code class="methodname">SetPollingInterval(long
      interval)</code> can be used to modify the polling interval while
      the polling loop is running. The
      <code class="interfacename">IChangeNotifier</code> implementation is
      responsible for its own thread management, so the calling application
      does not need to create a new thread to run the
      <code class="interfacename">IChangeNotifier</code> instance in.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2030"></a>Database Considerations</h3></div></div></div><p>The change notification support of TMCore relies on a set of
        database triggers and tables to record the details of a change event.
        The triggers are used to log events to the tables, and the change
        notification system queries these tables to determine what the most
        recent changes are. Updating these tables adds an overhead to every
        update of the topic map and for some applications, where change
        polling is not a requirement, this overhead may be unecessary.</p><p>By default, a TMCore installation has change logging enabled. To
        disable the change logging, the database owner must run the script
        found at
        <code class="filename"><em class="replaceable"><code>INSTALL_DIR</code></em>/scripts/disable-changelog.sql</code>.
        To enable change logging on again, the database owner must rung the
        script found at
        <code class="filename"><em class="replaceable"><code>INSTALL_DIR</code></em>/scripts/enable-changelog.sql</code>.</p><p>Even if change logging is enabled, to maintain database
        performance we recommend that you periodically purge the change event
        logging tables. This can be done by executing the stored procedure
        TM_CLEAR_CHANGELOG. This procedure takes two optional parameters as
        described below:</p><div class="variablelist"><dl><dt><span class="term">@tm</span></dt><dd><p>This integer parameter specifies the ID of the topic map
              to delete change log information for. If this parameter is not
              speciifed, then the change log information for all topic maps
              will be purged.</p></dd><dt><span class="term">@leaveLast</span></dt><dd><p>This integer parameter specifies the maximum number of
              rows to leave in each change log table after the purge. The
              value specifies the maximum difference between the ID of the
              highest change entry and the ID of the entries to leave in the
              log after purging. The purpose of this is to ensure that any
              applications that are polling the database for changes do not
              miss a log because it is created and then purged between polling
              cycles. This parameter defaults to a value of 1000 which should
              ensure that most applications with an average update frequency
              (100 additions, deletions and modifications per minute) and
              reasonably frequent polling frequency (of the order of 5 minutes
              between polling cycles) should not lose events, however if you
              have applications with a higher frequency of changes or which
              poll on a less frequent interval you should specify this
              parameter with a higher value.</p></dd></dl></div><div class="note"><h3 class="title">Note</h3><p>By default, permission to execute the TM_CLEAR_CHANGELOG
          procedure is granted only to the database owner role.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ApplicationOntology"></a>The ApplicationOntology Object</h2></div></div></div><p>Every topic map application will be governed by its own unique topic
  map schema and its own unique system of topic instances. In most
  applications, the schema will be used to represent all the types of concepts
  presented by the site and the types of relationships between those concepts
  and between the concepts and other resources. You may also have a set of
  predefined topics that are used for classification purposes (often referred
  to as a taxonomy) - some more complex applications may include several
  taxonomies.</p><p>The class
  <code class="classname">NetworkedPlanet.TMCore.Utils.ApplicationOntology</code>
  provides a fast and convenient means of accessing the key topics that are
  part of both the topic map schema and any taxonomies that govern your
  application. Most importantly, the
  <code class="classname">ApplicationOntology</code> class provides a string
  replacement method that can be used in conjunction with the TMRQL query
  language, allowing you to embed human-readable references to topics within
  TMRQL queries without the need to do an explicit query of the subject
  identifiers table.</p><p>Before you can use the <code class="classname">ApplicationOntology</code>
  object effectively, you must assign a subject identifier to the topics you
  wish to be accessible. A subject identifier is simply a unique URI
  identifier for a topic.</p><div class="tip"><h3 class="title">Tip</h3><p>We recommend that you only ever create new subject identifiers under
    a base URI that you have control over - doing this will avoid the
    potential for any future integration problems with other sources of topic
    map information. There is one exception to this rule though, and that is
    when you want to make use of the identifiers already defined by another
    individual or organisation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2086"></a>How the <code class="classname">ApplicationOntology</code> Works</h3></div></div></div><p>The <code class="classname">ApplicationOntology</code> class works by taking
    a configured list of mappings from short identifiers to full subject
    identifiers and then using these full subject identifiers to look-up a
    topic from one of a set of topic maps, returning the topic's unique object
    ID. This shortening of identifiers can make your queries much easier to
    read and also a lot shorter as it removes the need to explicitly look for
    a topic by its subject identifier - you can simply insert the short
    identifier for the topic in the place where you would normally have to
    type the object identifier for the topic. In addtion, the
    <code class="classname">ApplicationOntology</code> object caches successful
    lookups to make subsequent requests for the same topic much faster than
    embedding the lookup as part of a TMRQL query.</p><p>From a programming perspective, once it is configured the
    <code class="classname">ApplicationOntology</code> object works like a read-only
    Dictionary where the keys are short identifier strings and the values
    return are <code class="interfacename">ITopic</code> instances.</p><p>The <code class="classname">ApplicationOntology</code> class supports two
    forms of mapping between short identifiers and full subject identifiers.
    The simplest form of mapping is simply to map a short identifier string to
    a complete subject identifier. This simple form of mapping is useful for
    one-off or small numbers of mappings, but in some cases you may have tens,
    hundreds or even thousands of URIs to map. In this case you can make use
    of the second form of mapping in which short identifier prefix is mapped
    to subject identifier prefix. Once this mapping is made you can refer to a
    full subject identifier by specifying the short prefix followed by the
    remaining part of the identifier with a colon (:) separator. For example,
    if you map the short identifier prefix "org" to the subject identifier
    prefix "http://www.networkedplanet.com/2005/01/organisation/", then to
    refer to the topic with the full subject identifier
    "http://www.networkedplanet.com/2005/01/organisation/article", you would
    use the short reference "org:article".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2113"></a>Configuring The Application Ontology</h3></div></div></div><p>The Application Ontology object is configured in two steps. The
    first step is to define the mappings between short identifiers (or short
    identifier prefixes) and subject identifiers (or subject identifier
    prefixes), and the second step is to specify which topic map or topic maps
    should be searched for topics with the mapped subject identifiers during a
    look-up.</p><p>The definition of the mappings can be done using an XML fragment.
    This fragment can be part of a larger configuration file or a separate
    file itself. The TMCore library provides a helper class to allow you to
    embed the mappings as part of an application configuration (or web.config)
    file.</p><p>The format of the XML fragment is as follows:</p><pre class="programlisting">&lt;ontology&gt;
  &lt;identifierPrefix prefix="..." value="..."/&gt;
  &lt;subject key="..." identifier="..."/&gt;
&lt;/ontology&gt;
</pre><div class="variablelist"><dl><dt><span class="term">ontology</span></dt><dd><p>The root element for the configuration fragment.</p></dd><dt><span class="term">identifierPrefix</span></dt><dd><p>This element specifies a mapping between a short identifier
          prefix and a subject identifier prefix. The short identifier prefix
          is specified as the value of the <code class="sgmltag-element">prefix</code> attribute
          and the subject identifier prefix is specified as the value of the
          <code class="sgmltag-element">value</code> attribute.</p></dd><dt><span class="term">subject</span></dt><dd><p>This element specifies a mapping between a short identifier
          and a full subject identifier for a topic. The short identifier is
          specified as the value of the <code class="sgmltag-element">key</code> attribute and
          the full subject identifier is specified as the value of the
          <code class="sgmltag-element">identifier</code> attribute.</p></dd></dl></div><div class="note"><h3 class="title">Note</h3><p>The ontology element may contain any number of
      <code class="sgmltag-element">identifierPrefix</code> or <code class="sgmltag-element">subject</code>
      elements in any order.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2164"></a>Configuring from Web.Config or App.Config files</h4></div></div></div><p>If you wish your application to use an Application Ontology object
      configured from the application's configuration file, you can make use
      of the application section handler that is part of the TMCore library.
      To do this you will need to add the following line into the
      <code class="sgmltag-element">configSections</code> part of the application configuration
      file:</p><pre class="programlisting">&lt;section name="ontology" type="NetworkedPlanet.TMCore.Utils.OntologySectionHandler, tmcore"/&gt;</pre><p>From within your code, you can then use this section handler to
      retrieve an instance of the
      NetworkedPlanet.TMCore.Utils.ApplicationOntology class that represents
      the configured Application Ontology. e.g.</p><pre class="programlisting">ApplicationOntology ontology = 
  System.Configuration.ConfigurationSettings.GetConfig(
    "ontology") as ApplicationOntology;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2178"></a>Configuring from an XML file</h4></div></div></div><p>If you wish to use the XML configuration from some configuration
      file other than the application configuration file, you must instead
      pass the XmlElement object that represents the ontology element to the
      constructor of the ApplicationOntology class. e.g.</p><pre class="programlisting">ApplicationOntology applicationOntology;
XmlDocument configDoc = new XmlDocument();
configDoc.Load("myconfig.xml")
XmlElement ontologyElement = configDoc.SelectSingleNode("/config/ontology");
if (ontologyElement != null) {
  applicationOntology = new ApplicationOntology(ontologyElement);
} else {
  applicationOntology = new ApplicationOntology();
}
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2185"></a>Configuring Programatically</h4></div></div></div><p>Finally, it is also possible to set up all of the mappings for the
      Application Ontology directly from code. The methods for doing this are
      <code class="methodname">ApplicationOntology.AddPrefix(string shortIdPrefix, string
      subjectIdentifierPrefix)</code> and
      <code class="methodname">ApplicationOntology.AddIdentifier(string shortId, string
      subjectIdentifier)</code>. e.g.</p><pre class="programlisting">ApplicationOntology ontology = new ApplicationOntology();
ontology.AddPrefix("org", "http://www.networkedplanet.com/2005/01/organisation/");
ontology.AddIdentifier("title", "http://purl.org/dc/1.1/title");</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2198"></a>Specifying Topic Maps</h4></div></div></div><p>The second step in configuring an ApplicationOntology instance for
      use is to specify the topic map or topic maps on which it operates.
      These topic maps are the ones in which the Application Ontology object
      will search for topics by their full subject identifier. The Application
      Ontology object will search the topic maps it is connected to in strict
      order, returning the first topic that matches. A topic map can be added
      to the end of the search list using the method
      <code class="methodname">ApplicationOntology.AddTopicMap(ITopicMap tm)</code>
      and can be removed using the method
      <code class="methodname">ApplicationOntology.RemoveTopicMap(ITopicMap tm).
      e.g.</code></p><pre class="programlisting">ITopicMap coreMap = m_topicMapSystem.GetTopicMap("core.xtm");
ontology.AddTopicMap(coreMap)
</pre><div class="note"><h3 class="title">Note</h3><p>Whenever you add a new topic map to the search list for an
          ApplicationOntology instance or remove a topic map from its search
          list, the cache of topics found up until that point will be dropped.
          You should therefore avoid constantly reconfiguring the list of
          topic maps connected to an ApplicationOntology instance to maximise
          the potential for caching.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2213"></a>Combining ApplicationOntology instances</h4></div></div></div><p>In some cases you may want to combine a predefined set of mappings
      that are set up programatically with a user-defined set of mappings
      which could be specified in an app.config or other XML configuration
      file. To support this you may nest one ApplicationOntology instance
      within another. Every ApplicationOntology instance supports just one
      nested instance. When an ApplicationOntology is asked to map a short
      identifier, it will first attempt to perform the mapping to a full
      subject identifier and then to a topic using its own configured mappings
      and topic maps, if that fails to find a match the short identifier will
      then be passed to the nested ApplicationOntology instance for it to
      resolve (and if that instance cannot resolve the short identifier, it
      will in turn pass the identifier on to its nested instance - if any -
      and so on).</p><p>The nested ontology can only be specified through the use of the
      appropriate constructor for the ApplicationOntology object. e.g.</p><pre class="programlisting">// Get the inner ontology from the application configuration file
ApplicationOntology innerOntology = 
  System.Configuration.ConfigurationSettings.GetConfig(
    "ontology") as ApplicationOntology;

// Create an outer ontology programatically:
ApplicationOntology outerOntology = new ApplicationOntology(innerOntology);
outerOntology.AddPrefix("org", "http://www.networkedplanet.com/2005/01/organisation/");
</pre><div class="note"><h3 class="title">Note</h3><p>It is still possible to use an ApplicationOntology instance
        which is nested inside another instance directly too, bypassing the
        outer ontology's lookups if necessary. In the example above your code
        could use either outerOntology (which adds a mapping for the prefix
        "org") or innerOntology to avoid the additional mappings specified by
        outerOntology.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2225"></a>Using the <code class="classname">ApplicationOntology</code></h3></div></div></div><p>The <code class="classname">ApplicationOntology</code> class provides two
    basic modes of use: as a dictionary of values or as a string
    filter.</p><p>To use the <code class="classname">ApplicationOntology</code> class as a
    dictionary, simply index into it using short identifiers as you would with
    any other <code class="interfacename">IDictionary</code> implementation. The
    <code class="classname">ApplicationOntology</code> class returns an
    <code class="interfacename">ITopic</code> instance if a match is found for the
    short identifier and null otherwise. e.g.</p><pre class="programlisting">// Create a new ontology with one prefix mapping and one short identifier mapping
ApplicationOntology ontology = new ApplicationOntology();
ontology.AddPrefix("org", "http://www.networkedplanet.com/2005/01/organisation/");
ontology.AddIdentifier("title", "http://purl.org/dc/1.1/title");
ontology.AddTopicMap(myTopicMap);

ITopic person = ontology["org:person"];
ITopic title = ontology["title"];
</pre><p>The <code class="classname">ApplicationOntology</code> class also provides
    two methods which allow the class to act as a string processor. In this
    mode, the input string is searched for tokens enclosed in curly braces.
    These tokens are then matched against the
    <code class="classname">ApplicationOntology</code> and if an
    <code class="interfacename">ITopic</code> instance is returned, then the token
    and the braces are replaced by the unique object identifier for the
    <code class="interfacename">ITopic</code> instance. This is most useful in
    processing TMRQL query strings prior to evaluating them. The method
    <code class="methodname">ApplicationOntology.ReplaceReferences(string
    input)</code> works in exactly this way, but the method
    <code class="methodname">ApplicationOntology.ReplaceReferences(string input, ITopic
    focusTopic)</code> will also match the tokens {FocusTopic} and
    {TopicMap}, with the former being replaced by the unique object identifier
    of the <code class="interfacename">ITopic</code> that is specified in the
    <em class="parameter"><code>focusTopic</code></em> parameter and the latter being replaced
    by the unique object identifier of the
    <code class="interfacename">ITopicMap</code> instance that contains
    <em class="parameter"><code>focusTopic</code></em>.</p><pre class="programlisting">// Assuming ontology is already configured as shown in the previous example

// A query string containing a replacement value
string query = "select topic_id from tm_topic where type_id={org:person}";

// Expand the query using the application ontology
string expandedQuery = ontology.ReplaceReferences(query);

// Finally, execute the expanded query
ITMCoreDataReader dr = myTopicMapSystem.ExecuteQuery(expandedQuery);
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2285"></a>Creating and Accessing Topic Hierarchies</h2></div></div></div><p>The class
      <code class="classname">NetworkedPlanet.TMCore.Utils.HierarchyManager</code>
      provides a simple means of managing multiple topic hierarchies in a
      topic map. The <code class="classname">HierarchyManager</code> class is capable
      of scanning a topic map for all topic hierarchies which are defined in a
      particular way and then extracting and caching the details of the
      hierarchy in memory for fast access to the hierarchy of topics.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2296"></a>Creating a Hierarchy</h3></div></div></div><p>In order for the <code class="classname">HierarchyManager</code> class
        to recognise a hierarchy, it is necessary to provide a
        <span class="emphasis"><em>hierarchy topic</em></span> which defines the hierarchy
        itself. This hierarchy topic contains associations to:</p><div class="itemizedlist"><ul type="disc"><li><p>the root topic of the hierarchy</p></li><li><p>a set of association type topics that will connect parent
            and child nodes.</p></li><li><p>a set of topics that represent the parent type roles between
            nodes of the hierarchy.</p></li><li><p>a set of topics that represent the child type roles between
            nodes of the hierarchy.</p></li></ul></div><p>Two topics are connected to partipicate in a hierarchy in a
        parent-child relationship iff:</p><div class="itemizedlist"><ul type="disc"><li><p>There is an association between the parent and child where
            the association type topic of the association is connected to the
            hierarchy topic.</p></li><li><p>There is an association between the parent and child where
            the parent topic plays one of the roles identified by the
            hierarchy topic.</p></li><li><p>There is an association between the parent and child where
            the child topic plays one of the roles identified by the hierarchy
            topic.</p></li></ul></div><p>The hierarchy topic and the types of associations used to
        specify the root topic and the hierarchy association types all use a
        fixed set of PSIs which are defined by Techquila (see <a href="http://www.techquila.com/psi/" target="_top">http://www.techquila.com/psi/</a>).</p><p>In the model specified by Techquila, each hierarchy must be
        defined by a topic of type "Facet". This topic represents the entire
        hierarchy as a whole and so should be given a name that reflects the
        name of the whole hierarchy. This topic is not the root of the
        hierarchy - it only acts to define how to find the hierarchy and how
        to traverse it. The root of the hierarchy is identified using an
        association of the type "Facet-Has-Root". This association must be a
        binary association between the topic representing the hierarchy
        (playing the role "Facet") and the topic which is the root of the
        hierarchy (playing the role "Facet-Root"). The hierarchy must be
        constructed as a set of topics all connected together using the same
        type of association. The type of association used to construct the
        hierarchy is identified using an association of the type
        "Facet-Has-Hierarchy-Type". This association must also be a binary
        association between the topic representing the hierarchy (playing the
        role "Facet") and the topic which types the associations used to
        construct the hierarchy (playing the role "Facet-Hierarchy-Type").
        Finally, the association roles played by the topics in the hierarchy
        must be divided into superordinate roles (i.e. the role played by the
        "parent" in the hierarchy) and subordinate roles (the role played by
        the "child" in the hierarchy). This is done by creating associations
        of type "Facet-Has-Superordinate-Role-Type" and
        "Facet-Has-Subordinate-Role-Type" between the facet topic and the
        topics defining the parent role type and child role type
        respectively.</p><p>All of the types described above have a Published Subject
        Identifier (PSI) defined for them by Techquila and summarised in the
        table below. If you follow the PSI URL you will be taken to pages
        which provide the official Techquila description for each of these
        topics.</p><div class="table"><a name="hierarchy-psis"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Topic PSIs for Topic Hierarchies</b></p><table summary="Topic PSIs for Topic Hierarchies" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col></colgroup><thead><tr><th>Topic</th><th>PSI</th></tr></thead><tbody><tr><td>Facet</td><td>
                  <a href="http://www.techquila.com/psi/faceted-classification/#facet" target="_top">http://www.techquila.com/psi/faceted-classification/#facet</a>
                </td></tr><tr><td>Facet-Has-Hierarchy-Type</td><td>
                  <a href="http://www.techquila.com/psi/faceted-classification/#facet-has-hierarchy-type" target="_top">http://www.techquila.com/psi/faceted-classification/#facet-has-hierarchy-type</a>
                </td></tr><tr><td>Facet-Hierarchy-Type</td><td>
                  <a href="http://www.techquila.com/psi/faceted-classification/#facet-hierarchy-type" target="_top">http://www.techquila.com/psi/faceted-classification/#facet-hierarchy-type</a>
                </td></tr><tr><td>Facet-Has-Root</td><td>
                  <a href="http://www.techquila.com/psi/faceted-classification/#facet-has-root" target="_top">http://www.techquila.com/psi/faceted-classification/#facet-has-root</a>
                </td></tr><tr><td>Facet-Root</td><td>
                  <a href="http://www.techquila.com/psi/faceted-classification/#facet-root" target="_top">http://www.techquila.com/psi/faceted-classification/#facet-root</a>
                </td></tr><tr><td>Facet-Has-Subordinate-Role-Type</td><td>http://www.techquila.com/psi/faceted-classification/#facet-has-subordinate-role-type</td></tr><tr><td>Subordinate-Role-Type</td><td>
                  <a href="http://www.techquila.com/psi/hierarchy/#subordinate-role-type" target="_top">http://www.techquila.com/psi/hierarchy/#subordinate-role-type</a>
                </td></tr><tr><td>Facet-Has-Superordinate-Role-Type</td><td>http://www.techquila.com/psi/faceted-classification/#facet-has-superordinate-role-type</td></tr><tr><td>Superordinate-Role-Type</td><td>
                  <a href="http://www.techquila.com/psi/hierarchy/#superordinate-role-type" target="_top">http://www.techquila.com/psi/hierarchy/#superordinate-role-type</a>
                </td></tr></tbody></table></div><p>The diagram below shows this model in a schematic form.</p><div class="figure"><a name="d0e2420"></a><p class="title"><b>Figure&nbsp;8.1.&nbsp;Defining A Hierarchy Model</b></p><div class="mediaobject"><img src="../graphics/tmcore-api-guide/HierarchyStructure.png" alt="Defining A Hierarchy Model"></div></div><p>Although this may seem a little complex from the description
        above, it is actually very straightforward. The following procedure
        takes you through the process of defining a new hierarchy in an XTM
        topic map step by step.</p><div class="procedure"><a name="d0e2428"></a><p class="title"><b>Procedure&nbsp;8.1.&nbsp;Creating a Topic Hierarchy</b></p><ol type="1"><li><p class="title"><b>Create Or Import Techquila PSIs</b></p><p>This step only has to be performed once for each topic map
            and can be skipped by using <code class="sgmltag-element">subjectIndicatorRef</code>
            rather than <code class="sgmltag-element">topicRef</code> elements to refer to the
            Techquila topics. This can also be done through the TMCore Topic
            Map Editor web application or by invoking the static
            <code class="methodname">CreateHierarchySchemaTopics(ITopicMap)</code>
            method on the
            <code class="classname">NetworkedPlanet.TMCore.Utils.HierarchyManager</code>
            class.</p></li><li><p class="title"><b>Create The Hierarchy Facet</b></p><p>This is the topic which defines the hierarchy as a whole.
            This topic must be an instance of the Techquila topic "Facet". In
            XTM this can be achieved as follows:</p><pre class="programlisting">&lt;topic id="places"&gt;
  &lt;instanceOf&gt;
    &lt;subjectIndicatorRef xlink:href="http://www.techquila.com/psi/faceted-classification/#facet"/&gt;
  &lt;/instanceOf&gt;
  &lt;baseName&gt;
    &lt;baseNameString&gt;Places&lt;/baseNameString&gt;
  &lt;/baseName&gt;
  &lt;!-- Any other topic data --&gt;
&lt;/topic&gt;</pre><div class="note"><h3 class="title">Note</h3><p>The <code class="sgmltag-element">baseName</code> elements shown in this and
              all following examples are illustrative only - they are not
              required in constructing your hierarchy.</p></div></li><li><p class="title"><b>Create The Hierarchy Root</b></p><p>This is the topic that will be at the root of the hierarchy.
            Hierarchies can only have a single root topic. The root topic can
            be of any type (or types) you like. For example:</p><pre class="programlisting">&lt;topic id="the-world"&gt;
  &lt;instanceOf&gt;&lt;topicRef xlink:href="planet"/&gt;&lt;/instanceOf&gt;
  &lt;baseName&gt;
    &lt;baseNameString&gt;The World&lt;/baseNameString&gt;
  &lt;/baseName&gt;
&lt;/topic&gt;</pre><p>To identify this topic as the hierarchy root, you must
            create a "Facet-Has-Root" association between the facet topic
            created in step 2 and this root topic:</p><pre class="programlisting">&lt;!-- The root of the "Places" hierarchy is "The World" --&gt;
&lt;association&gt;
  &lt;instanceOf&gt;
    &lt;subjectIndicatorRef 
      xlink:href="http://www.techquila.com/psi/faceted-classification/#facet-has-root"/&gt;
  &lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef
        xlink:href="http://www.techquila.com/psi/faceted-classification/#facet"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#places"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef
        xlink:href="http://www.techquila.com/psi/faceted-classification/#facet-root"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#the-world"/&gt;
  &lt;/member&gt;
&lt;/association&gt;
</pre></li><li><p class="title"><b>Specify The Hierarchy Association Type</b></p><p>All topics in our hierarchy must be associated with one
            another using a single type of association. The topic for that
            association type must be identified using a
            "Facet-Has-Hierarchy-Type" association between the facet topic
            created in step 2 and the association typing topic. For
            example:</p><pre class="programlisting">&lt;topic id="contains"&gt;
  &lt;baseName&gt;
    &lt;baseNameString&gt;Contains&lt;/baseNameString&gt;
  &lt;/baseName&gt;
&lt;/topic&gt;

&lt;!-- The hierarchy association for "Places" hierarchy is "Contains" --&gt;
&lt;association&gt;
  &lt;instanceOf&gt;
    &lt;subjectIndicatorRef 
      xlink:href="http://www.techquila.com/psi/faceted-classification/#facet-has-hierarchy-type"/&gt;
  &lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef
        xlink:href="http://www.techquila.com/psi/faceted-classification/#facet"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#places"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef
        xlink:href="http://www.techquila.com/psi/faceted-classification/#facet-hierarchy-type"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#contains"/&gt;
  &lt;/member&gt;
&lt;/association&gt;</pre></li><li><p class="title"><b>Specify the Subordinate and Superordinate Roles</b></p><p>The subordinate role is the role played by the child in a
            hierarchy association; the superordinate role is the role played
            by the parent. These are identified by creating additional
            associations between the topic that defines the hierarchy and the
            topics that define the subordinate and superordinate role types.
            So for our "Contains" association type, we have the role types
            "Container" (the superordinate role type) and "Containee" (the
            subordinate role type):</p><pre class="programlisting">&lt;!-- Container role is a superordinate role type --&gt;
&lt;topic id="container"&gt;
  &lt;baseName&gt;
    &lt;baseNameString&gt;Container&lt;/baseNameString&gt;
  &lt;/baseName&gt;
&lt;/topic&gt;

&lt;association&gt;
  &lt;instanceOf&gt;
    &lt;subjectIndicatorRef
      xlink:href="http://www.techquila.com/psi/faceted-classification/#facet-has-superordinate-role-type"/&gt;
  &lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef xlink:href="http://www.techquila.com/psi/faceted-classification/#facet"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#places"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef
        xlink:href="http://www.techquila.com/psi/hierarchy/#superordinate-role-type"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#container"/&gt;
  &lt;/member&gt;
&lt;/association&gt;

&lt;!-- Containee role is a subordinate role type --&gt;
&lt;topic id="containee"&gt;
  &lt;baseName&gt;
    &lt;baseNameString&gt;Containee&lt;/baseNameString&gt;
  &lt;/baseName&gt;
&lt;/topic&gt;

&lt;association&gt;
  &lt;instanceOf&gt;
    &lt;subjectIndicatorRef
      xlink:href="http://www.techquila.com/psi/faceted-classification/#facet-has-subordinate-role-type"/&gt;
  &lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef xlink:href="http://www.techquila.com/psi/faceted-classification/#facet"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#places"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;
      &lt;subjectIndicatorRef
        xlink:href="http://www.techquila.com/psi/hierarchy/#subordinate-role-type"/&gt;
    &lt;/roleSpec&gt;
    &lt;topicRef xlink:href="#containee"/&gt;
  &lt;/member&gt;
&lt;/association&gt;</pre></li><li><p class="title"><b>Create Hierarchy Associations</b></p><p>Now create as many hierarchy associations as necessary. When
            specifiying all the children of a single topic in the hierarchy
            you can use either one association with multiple subordinate role
            players or multiple binary associations. Note that these
            associations are completely free of the supporting topic
            infrastructure used to create the hierarchy. This means that any
            other topic map application that is not aware of the significance
            of the Techquila PSIs will still present the container/containee
            relationships as intended.</p><pre class="programlisting">&lt;!-- The World contains Europe --&gt;
&lt;association&gt;
  &lt;instanceOf&gt;&lt;topicRef xlink:href="#contains"/&gt;&lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;&lt;topicRef xlink:href="#container"/&gt;&lt;/instanceOf&gt;
    &lt;topicRef xlink:href="#the-world"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;&lt;topicRef xlink:href="#containee"/&gt;&lt;/instanceOf&gt;
    &lt;topicRef xlink:href="#europe"/&gt;
  &lt;/member&gt;
&lt;/association&gt;

&lt;!-- Europe contains UK and France --&gt;
&lt;association&gt;
  &lt;instanceOf&gt;&lt;topicRef xlink:href="#contains"/&gt;&lt;/instanceOf&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;&lt;topicRef xlink:href="#container"/&gt;&lt;/instanceOf&gt;
    &lt;topicRef xlink:href="#europe"/&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;roleSpec&gt;&lt;topicRef xlink:href="#containee"/&gt;&lt;/instanceOf&gt;
    &lt;topicRef xlink:href="#uk"/&gt;
    &lt;topicRef xlink:href="#france"/&gt;
  &lt;/member&gt;
&lt;/association&gt;</pre></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2493"></a>Using The HierarchyManager API</h3></div></div></div><p>The class
        <code class="classname">NetworkedPlanet.TME.Utils.HierarchyManager</code>
        provides access to all of the hierarchies contained in a single topic
        map. The constructor for the class takes a single
        <code class="interfacename">ITopicMap</code> parameter which defines the
        topic map which the manager should process. During the constructor,
        the topic map is interrogated for all facets and the
        <code class="classname">HierarchyManager</code> will attempt to process each
        of those facets as a hierarchy. If the the subject identifiers
        specified in <a href="#hierarchy-psis" title="Table&nbsp;8.1.&nbsp;Topic PSIs for Topic Hierarchies">Table&nbsp;8.1, &#8220;Topic PSIs for Topic Hierarchies&#8221;</a> are not all found in
        the topic map, a ERROR level message will be written to the
        <code class="classname">HierarchyManager</code> log (see <a href="#logging" title="Chapter&nbsp;14.&nbsp;Logging">Chapter&nbsp;14, <i>Logging</i></a> for more details); a
        <code class="exceptionname">TopicMapProcessingException</code> will be
        thrown and no hierarchies will be loaded. If some of the facets do not
        conform to the structure required for a hierarchical facet, a WARNING
        level message will be written to the
        <code class="classname">HierarchyManager</code> log, but the correctly
        structure facets will all be processed. The constructor code caches
        the hierarchy in memory to provide rapid access to the entire
        tree.</p><p>Once the <code class="classname">HierarchyManager</code> constructor
        returns, the hierarchies found can be accessed through the
        <span class="property">Hierarchies</span> property. This returns an
        unmodifiable <code class="interfacename">IList</code> of
        <code class="classname">NetworkedPlanet.TME.Utils.Hierarchy</code> instances.
        A <code class="classname">Hierarchy</code> instance represents the meta-data
        for a hierarchy. This includes the
        <code class="interfacename">ITopic</code> that defines the hierarchy and
        the <code class="interfacename">ITopic</code> that defines the hierarchy
        association type. In addition, the root node of the hierarchy can be
        accessed through the <span class="property">Root</span> property.</p><p>The <span class="property">Root</span> property returns an instance of
        <code class="classname">NetworkedPlanet.TME.Utils.HierarchyNode</code>. This
        class is used to represent a single node in the hierarchy tree. The
        property <span class="property">Topic</span> provides access to the underlying
        <code class="interfacename">ITopic</code> in the topic map and the
        property <span class="property">Children</span> returns an unmodifiable
        <code class="interfacename">IList</code> of
        <code class="classname">HierarchyNode</code> instances representing all of the
        children of this node in the hierarchy. The properties
        <span class="property">Parent</span> and <span class="property">Hierarchy</span> allow
        direct access to the parent node in the hierarchy and the hierarchy
        definition respectively.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2575"></a>Hierarchy Manager Example</h3></div></div></div><p>To help users with understanding how to create and use the
        <code class="classname">HierarchyManager</code> and its support classes:
        <code class="classname">HierarchyNode</code> and
        <code class="classname">Hierarchy</code> we have included an example
        applications.</p><p>The C# example project may be found in the TMCore
        <code class="filename">examples\CS\HierarchyExample</code> directory (no Visual
        Basic version is supplied). For information about how to use the
        TMCore examples, refer to <a href="#compiling-examples" title="Compiling and Running the Examples">the section called &#8220;Compiling and Running the Examples&#8221;</a>.</p><p>The example creates a topic map representing a well-known family
        and the relationships between them. For simplicity only two
        associations types are considered: parenthood and siblings. The
        example then goes on to demonstrate how to create and navigate
        hierarchies using these family relationships.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querying"></a>Chapter&nbsp;9.&nbsp;Querying</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e2605">Using TMCore Public Views And Functions</a></span></dt><dt><span class="section"><a href="#executing.queries">Executing Queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2793">Other Options For Working With Results Sets</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2847">Querying Efficiently</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2862">Limiting Data Read In A Results Row</a></span></dt><dt><span class="section"><a href="#d0e2876">Performing Query Analysis</a></span></dt><dt><span class="section"><a href="#d0e2896">Use The ApplicationOntology Cache Object</a></span></dt></dl></dd></dl></div><p>TMCore is built on relational database technology and exposes a
    complete relational data model for the topic maps managed by the system.
    The model consists of a set of views and pre-defined SQL functions which
    can be used to construct arbitrary queries across all topic map data using
    any of the SQL constructs supported by the underlying database - this
    includes statistical functions; data conversion fucntions; full-text query
    extensions and so on. Unlike the indexes covered in <a href="#basicindexes" title="The Core Indexes">the section called &#8220;The Core Indexes&#8221;</a>, the relational model also allows multiple topic
    maps to be queried simultaneously.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2605"></a>Using TMCore Public Views And Functions</h2></div></div></div><p>The TMCore engine installs a number of public views and
      user-defined functions into the SQL database. These views and functions
      are easily identified as they have names starting with the prefix "tm_".
      These views and functions are documented in the <a href="../query-reference.html" target="_top">TMCore Query Reference
      Sheet</a>.</p><div class="warning"><h3 class="title">Warning</h3><p>You are strongly advised NOT to write queries which make use of
        the private tables and views as these may be subject to change either
        in structure or in content in future versions of the software and so
        an upgrade may cause your queries to function in unexpected
        ways.</p></div><p>You can use these views and functions in exactly the same way as
      you would use any normal SQL view or function. For example you can use
      the tm_displayName function to transform a topic id into a display name
      for the topic. For example the query:</p><div class="literallayout"><p>select&nbsp;tm_displayName(r1p)&nbsp;from&nbsp;tm_assoc&nbsp;where&nbsp;association_id=123</p></div><p>would return the display name for each topic which plays a role in
      the association with the ID "123". Some of the functions defined by
      TMCore return table values which allows you to use them in a select or
      sub-select. For example you can use the tm_instanceOf function to return
      the classes and superclasses of a topic with a query such as:</p><div class="literallayout"><p>select&nbsp;class_id&nbsp;from&nbsp;tm_instanceOf(<em class="replaceable"><code>tm</code></em>,&nbsp;<em class="replaceable"><code>topic</code></em>,&nbsp;NULL)</p></div><p>where <em class="replaceable"><code>tm</code></em> and
      <em class="replaceable"><code>topic</code></em> should be replaced with the ID value of
      the topic map and the instance topic respectively.</p><p>A full tutorial on the SQL query language is beyond the scope of
      this document. The <a href="../query-reference.html" target="_top">TMCore Query
      Reference Sheet</a> gives full documentation of each view and query
      provided by TMCore.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="executing.queries"></a>Executing Queries</h2></div></div></div><p>The interface <code class="interfacename">ITopicMapSystem</code>
      provides a single method
      <code class="methodname">ITopicMapSystem.ExecuteQuery(string)</code> through
      which an SQL query can be executed against the TMCore system. The method
      returns an instance of the
      <code class="interfacename">ITMCoreDataReader</code> interface which gives
      read-only access to the results of the query.</p><p>The <code class="interfacename">ITMCoreDataReader</code> interface
      extends the standard System.Data.IDataReader interface with the
      following additional methods:</p><code class="methodsynopsis"><span class="type">ITopic&nbsp;</span><span class="methodname">GetTopic</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><br><code class="methodsynopsis"><span class="type">ITopicName&nbsp;</span><span class="methodname">GetTopicName</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><br><code class="methodsynopsis"><span class="type">IOccurrence&nbsp;</span><span class="methodname">GetOccurrence</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><br><code class="methodsynopsis"><span class="type">IVariant&nbsp;</span><span class="methodname">GetVariant</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><br><code class="methodsynopsis"><span class="type">IAssociation&nbsp;</span><span class="methodname">GetAssociation</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><br><code class="methodsynopsis"><span class="type">IAssociationRole&nbsp;</span><span class="methodname">GetAssociationRole</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><br><code class="methodsynopsis"><span class="type">ITopicMapObject&nbsp;</span><span class="methodname">GetTopicMapObject</span>(<span class="methodparam"><span class="parameter"><span class="type">int&nbsp;</span> i</span></span>);</code><p>Each of the methods listed above take as their single parameter
      the zero-based position of the column from which the object's
      <span class="property">ObjectID</span> value is to be retrieved. The method then
      loads any additional data required from the database and returns an
      instance of the appropriate topic map object interface. The method
      <code class="methodname">GetTopicMapObject()</code> will determine the type of
      the object and return an instance of the appropriate dervied interface
      (e.g. an <code class="interfacename">IOccurrence</code> instance if the
      identifier is from an occurrence object). If the content of the
      specified column is not the object identifier of the requested type of
      topic map object, then an <code class="classname">InvalidCastException</code>
      will be raised.</p><div class="note"><h3 class="title">Note</h3><p>The <code class="methodname">GetTopicMapObject()</code> method uses
        additional database queries to determine the type of the object and so
        its use should be avoided unless the specified column can contain
        identifiers of a mixture of types of object.</p></div><p>As with other <code class="interfacename">IDataReader</code>s, the
      <code class="interfacename">ITMCoreDataReader</code> must be closed once it
      is no longer needed by calling the <code class="methodname">Close()</code>
      method. The TMCore code will create a new connection for each concurrent
      <code class="interfacename">ITMCoreDataReader</code> instance that your
      program holds open and unless these readers are closed when not needed,
      your application will quickly use up all the available connections
      leading to unexpected failures.</p><p>The code listing below shows an example of using the
      <code class="methodname">ITopicMapSystem.ExecuteQuery()</code> method to
      retrieve the topic names which contain the string "foo" and have a
      particular topic in their scope. Note that the call to the
      <code class="methodname">ITMCoreDataReader.Close()</code> method is enclosed in
      the finally block to ensure that it gets called even if the processing
      of a topic name results in an exception being raised.</p><div class="example"><a name="d0e2774"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Using ITMCoreDataReader</b></p><pre class="programlisting">ITopic scopingTopic;
ITopicMap tm;

// ... set up scopingTopic and tm

string query = "select v.name_id from " +
  "TM_nameValue join TM_nameScope on TM_nameValue.name_id=TM_nameScope.name_id" +
  "where TM_nameValue.name_value like '%foo%' and TM_nameScope.scoping_topic_id=" + scopingTopic.ObjectID;

ITMCoreDataReader dr = tm.TopicMapSystem.ExecuteQuery(query);
try {
  while (dr.Read()) {
    ITopicName tn = dr.GetTopicName(0);
    // Do something with the scoped name
  }
} finally {
  dr.Close();
}
</pre></div><p>The TopicMapSystem interface also supports executing queries with
      a set of parameters. This is STRONGLY RECOMMENDED when one or more
      parameters come from user input as SQL parameter values are properly
      escaped and checked for SQL injection attacks. There are two overrides
      of the ExecuteQuery method that support parameters. The method
      ExecuteQuery(String queryString, IList parameters) takes a list of
      System.Data.IDataParameter instances (e.g.
      System.Data.SqlClient.SqlParameter), this method gives you the most
      control over the parameters you pass at the expense of requiring you to
      instantiate each parameter object explicitly. The second override is
      ExecuteQuery(String queryString, Hashtable parameters), which takes a
      Hashtable of parameter values where the Hashtable key is the parameter
      name and the value is the parameter value. The parameter type is
      automatically inferred from the parameter value.</p><p>The code samples below show how these two overrides can be
      used.</p><div class="example"><a name="d0e2783"></a><p class="title"><b>Example&nbsp;9.2.&nbsp;Using ExecuteQuery(string, IList)</b></p><pre class="programlisting">string query = "select v.name_id " +
  "from tm_nameValue join tm_nameScope on tm_nameValue.name_id=tm_nameScope.name_id "+
  "where tm_nameValue.name_value like @name and tm_nameScope.scoping_topic_id=@scopingTopic";

ArrayList parameters = new ArrayList();
IDataParameter param = new SqlParameter();
param.Name = "@name";
param.DbType = DbType.String;
param.Value = "%foo%";
parameters.add(param);
param = new SqlParameter();
param.Name = "@scopingTopic";
param.DbType = DbType.Int32;
param.Value = scopingTopic.ID;
parameters.add(param);
ITMCoreDataReader dr = tm.TopicMapSystem.ExecuteQuery(query, parameters);</pre></div><div class="example"><a name="d0e2788"></a><p class="title"><b>Example&nbsp;9.3.&nbsp;Using ExecuteQuery(string, Hashtable)</b></p><pre class="programlisting">string query = "select v.name_id " +
  "from tm_nameValue join tm_nameScope on tm_nameValue.name_id=tm_nameScope.name_id "+
  "where tm_nameValue.name_value like @name and tm_nameScope.scoping_topic_id=@scopingTopic";

Hashtable parameters = new Hashtable();
parameters["@name"] = "%foo%";
parameters["@scopingTopic"] = scopingTopic.ID;
ITMCoreDataReader dr = tm.TopicMapSystem.ExecuteQuery(query, parameters);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2793"></a>Other Options For Working With Results Sets</h3></div></div></div><p>The <code class="interfacename">ITMCoreDataReader</code> interface
        provides two additional accessor methods which enable programmers to
        work with the results of a query in different ways.</p><p>The method
        <code class="methodname">ITMCoreDataReader.GetInternalDataReader()</code>
        returns the underlying <code class="interfacename">IDataReader</code>
        instance that is wrapped by the
        <code class="interfacename">ITMCoreDataReader</code>. For TMCore
        applications connecting to a Microsoft SQL Server or MSDE database,
        this <code class="interfacename">IDataReader</code> instance will be an
        instance of the class
        <code class="classname">System.Data.SqlClient.SqlDataReader</code>. In the
        future, as other databases are supported, the value returned by this
        method may be an instance of some database-specific implementation of
        the <code class="interfacename">IDataReader</code> interface.</p><div class="note"><h3 class="title">Note</h3><p>Calling the <code class="methodname">Close()</code> method on the
          <code class="interfacename">IDataReader</code> returned by
          <code class="methodname">GetInternalDataReader()</code> will have the
          side-effect of closing the
          <code class="interfacename">ITMCoreDataReader</code>.</p></div><p>The method
        <code class="methodname">ITMCoreDataReader.GetDataTable()</code> reads
        through the rows of the results set and creates and returns a
        <code class="classname">DataTable</code> instance containing all of the
        results. This method then closes the
        <code class="interfacename">ITMCoreDataReader</code>, so no further reads
        are possible. This method can be especially useful when working with
        data bindings such as in ASP pages.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2847"></a>Querying Efficiently</h2></div></div></div><p>There are three keys to efficient use of the TMCore's query
      facilities:</p><div class="orderedlist"><ol type="1"><li><p>Limiting the amount of data read in each results row.</p></li><li><p>Performing query analysis and indexing.</p></li><li><p>Make use of the ApplicationOntology cache object.</p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2862"></a>Limiting Data Read In A Results Row</h3></div></div></div><p>The helper methods <code class="methodname">GetTopic()</code>,
        <code class="methodname">GetAssociation()</code> and so on retrieve all of
        the data associated with the Topic or Association from either the
        local object cache or (if not in the cache) from the database. This
        retrieval requires additional queries and so can have a significant
        impact on query performance. If you require only a small amount of
        information (e.g. a topic name and an occurrence value), it is better
        to construct your query to return just these values than to return the
        ID of the topic and then use the <code class="methodname">GetTopic()</code>
        method and the API to retrieve the required values.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2876"></a>Performing Query Analysis</h3></div></div></div><p>As the TMCore query language is simply SQL, it is possible to
        perform query analyses using standard tools such as the Query Analyzer
        that is part of the SQL Server toolset. Such tools can help indicate
        performance bottle-necks in a query. By default, the TMCore
        installation does not index any of the public views that can be used
        in your queries, so to boost query performance, you have two
        options:</p><div class="orderedlist"><ol type="1"><li><p>Add indexes to the TMCore public views as indicated by your
            query analysis.</p><p>We do not recommend that you simply add indexes to all
            public views without first analyzing the most common and most
            time-consuming queries used by your system as over-use of indexes
            can impact database performance in other areas.</p></li><li><p>Create additional customised views using the TMCore public
            views as a source.</p><p>We do not recommend using the undocumented tables as a
            source for your customised views as these may change from one
            release of TMCore to another.</p></li></ol></div><p>To aid analysis, you may want to log queries as they are
        executed by your application. These are logged as DEBUG messages in
        the log category networkedplanet.tmcore.system. Please refer to <a href="#logging" title="Chapter&nbsp;14.&nbsp;Logging">Chapter&nbsp;14, <i>Logging</i></a> for more details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2896"></a>Use The ApplicationOntology Cache Object</h3></div></div></div><p>The ApplicationOntology object (described in ) enables you to
        write queries that use the unique object identifiers of topics without
        having to write your own lookup and caching code. By using a single
        <code class="classname">ApplicationOntology</code> object for your application
        you can make use of the efficient caching of topic identifiers and you
        can write your queries without having to include sub-queries to find
        ontology-related topics. Use the
        <code class="classname">ReplaceReferences()</code> method of the
        <code class="classname">ApplicationOntology</code> class to replace cache key
        references with topic identifiers in your query strings</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transactional.api"></a>Chapter&nbsp;10.&nbsp;Fast Topic Map Updates with the TransactionalPersistenceManager</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e2913">Introduction</a></span></dt><dt><span class="section"><a href="#d0e2922">Transactional API Usage</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2925">Basic Usage Pattern</a></span></dt><dt><span class="section"><a href="#d0e2953">Using the Tranactional API and Query API</a></span></dt><dt><span class="section"><a href="#d0e2958">Updating Topic Characteristics</a></span></dt><dt><span class="section"><a href="#d0e2963">Wildcards in Transaction Operations</a></span></dt><dt><span class="section"><a href="#d0e2970">Cautions On Use</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2985">Sample code</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2913"></a>Introduction</h2></div></div></div><p>
      The TMAPI-based interfaces such as ITopic, IAssociation and so on provide
      methods for both topic map read and update. These interfaces are relatively
      efficient when the topics and associations you access are small and / or
      you are modifying all of the topic or association structure. This is because
      the implementations of these classes retrieve the entire topic or association
      from the database, perform any modifications locally and then only return
      the state to the database when you call the Save() method.
    </p><p>
      However there
      are many cases where an application is required to only perform some
      relatively small incremental update on a large number of topics or
      associations in a database and in those cases, the overhead of retrieving
      the entire structure for an ITopic or IAssociation instance from the database
      can cause performance problems. For these circumstances we have provided
      a transaction-oriented API for topic map updates.
    </p><p>
      Unlike TMAPI which deals with objects and object states, the transactional
      API deals with operations on a topic map. Each operation in the transactional
      API is processed by a database stored procedure call which updates some
      part of a topic or association. Individual calls are therefore processed
      much more quickly than if the equivalent operation was implemented using
      TMAPI.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2922"></a>Transactional API Usage</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2925"></a>Basic Usage Pattern</h3></div></div></div><p>
      The basic pattern for using the transactional API is simple:
    </p><div class="orderedlist"><ol type="1"><li><p>Create an instance of the NetworkedPlanet.TMCore.Persistence.TransactionalPersistenceManager class.</p><p>The constructor takes an ITopicMapSystem instance as a parameter. So if
	you have an ITopicMap instance already, then you can use code like this:</p><pre class="programlisting">
// in the using section...
using NetworkedPlanet.TMCore.Persistence;
	  
// in your code:
TransactionalPersistenceManager tmpm = 
    new TransactionalPersistenceManager(tm.TopicMapSystem);
	</pre></li><li><p>Use the TransactionalPersistenceManager to create a new NetworkedPlanet.TMCore.Transaction class instance. This is achieved by calling the StartTransaction method:</p><pre class="programlisting">
Transaction txn = tmpm.StartTransaction();
	</pre></li><li><p>Make operation calls by invoking the methods of the Transaction class. See the API HTML Help file for a detailed description of each method. The sample code below creates a new topic and assigns a name and subject identifier to it. Note that the return values of the Transaction methods can be used in subsequent method calls in the same transaction, so it is possible to create a new topic and add names, occurrences and connect it into associations it all in a single transaction.</p><pre class="programlisting">
  int personId = txn.AddTopic(tm.ID, personType.ID); // assume personType is an ITopic instance
  txn.AddTopicName(person, -1, "John Smith", null, null);
  txn.AddSubjectIdentifier(person, -1, "http://www.example.com/people/jsmith");
	</pre></li><li><p>Commit all changes by calling the Commit() method of the Transaction instance or rollback changes by calling the Rollback() method.</p><pre class="programlisting">
// Sample structure for using a transaction
Transaction txn = tmpm.StartTransaction();
try 
{
  // Call Transaction methods here
  txn.Commit();
} 
catch (Exception ex) 
{
  txn.Rollback();
  // Handle exception or rethrow
}
	</pre></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2953"></a>Using the Tranactional API and Query API</h3></div></div></div><p>
	The transactional API is especially effective when used in combination with the query API. In 
	this case you should execute the queries you need to determine what items need
	to be created, deleted or modified before then using the transaction API
	pattern described above to perform the updates. We recommend that you DO NOT
	attempt to execute queries with a transaction - firstly because this can significantly
	lenghten the time that you hold the transaction open, and secondly because queries
	are issued on a separate database connection which may lead to them being 
	blocked by changes in your transaction that have not yet been committed.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2958"></a>Updating Topic Characteristics</h3></div></div></div><p>
	The transactional API does not currently include any methods for updating topic names, 
	variant names, occurrences or identifiers. The pattern for modifying one of these
	characteristics is to delete the old name, occurrence or identifier and then create
	a new one with the updated value.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2963"></a>Wildcards in Transaction Operations</h3></div></div></div><p>
	Several of the methods of the Transaction class that identify items to be deleted from a topic map support the use of wildcard values to be passed in parameters. These methods should be thought of as selecting for deletion all those items that match the criteria specified in the parameters to the method. Where string values are matched, the SQL wildcard characters (% and _) are allowed, enabling you to select all occurrences with a string value that starts "Test" by passing "Test%" as the string match value for example. Where topics are matched, a value of -1 can be passed to match any topic.
      </p><p>
	The main exceptions to this rule are where the methods have a parameter that specifies the parent topic or association to be affected - in this case a non-negative object OID value is required; and also where the methods take an array of integers to define a scope - to match any scope (including the unconstrained scope), pass null as the value of the scope matching parameter, otherwise the scope you specify must exactly match the scope of the item to be deleted.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2970"></a>Cautions On Use</h3></div></div></div><p>
	When using the transactional API, you should remember that every transaction
	you create is established in the context of its own database transaction. You
	should therefore be very careful to:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Always Commit() or Rollback() an Transaction when you are done with it.</p></li><li><p>Use try/catch blocks to ensure that you either Commit() the partially completed transaction or Rollback() the transaction if an exception is raised during processing.</p></li><li><p>Endeavour to keep transactions open for as short a time as possible - an open
	  transaction can potentially block not only other database writers but also other
	  database readers. If you have a large number of  updates to perform we recommend
	  that you break them down into smaller batches that each execute within a single
	  transaction.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2985"></a>Sample code</h2></div></div></div><p>
      Some sample code that uses the transactional API can be found in the sample code
      that comes with the TMCore installation.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="npcl-overview"></a>Chapter&nbsp;11.&nbsp;The NetworkedPlanet Constraint Language (NPCL)</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e2999">Key Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3004">Types</a></span></dt><dt><span class="section"><a href="#d0e3097">Constraints</a></span></dt><dt><span class="section"><a href="#d0e3147">Superclass-Subclass Inheritance</a></span></dt><dt><span class="section"><a href="#d0e3177">Scoping Topics</a></span></dt></dl></dd><dt><span class="section"><a href="#npcl-schema">NPCL XML Schema</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3185">Overview</a></span></dt><dt><span class="section"><a href="#d0e3193">Namespace</a></span></dt><dt><span class="section"><a href="#d0e3198"><code class="sgmltag-element">schema Element</code></a></span></dt><dt><span class="section"><a href="#d0e3255"><code class="sgmltag-element">abstractType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3298"><code class="sgmltag-element">topicType</code></a></span></dt><dt><span class="section"><a href="#d0e3393"><code class="sgmltag-element">occurrenceType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3466"><code class="sgmltag-element">associationType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3544"><code class="sgmltag-element">roleType</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3593"><code class="sgmltag-element">scopingTopic</code> Element</a></span></dt><dt><span class="section"><a href="#d0e3624"><code class="sgmltag-element">subclasses</code> Element</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3651">NPCL Topic Map Ontology</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3659">NPCL Meta Types</a></span></dt><dt><span class="section"><a href="#d0e3811">Constraint Topics</a></span></dt></dl></dd></dl></div><p>TMCore supports provides a set of utility APIs for managing the
  definitions of a set of constraints on a topic map. Constraints can be used
  to define what types of topics and associations can be created, what types
  of associations a topic of a specific type can participate in, what types of
  occurences can be given to a topic of a particular type and also to
  constrain the values of occurrences of a specific type. Constraints enable
  both topic map validation and also the creation of more user-friendly
  editing interfaces. These constraints are expressed using the
  NetworkedPlanet Constraint Language (NPCL).</p><p>This release of TMCore provides support for retrieving and modifying
  constraints stored either in the topic map itself or as a separate XML file
  conforming to the NPCL XML Schema. This release DOES NOT provide methods for
  validating topic maps against a set of constraints or for enforcing
  validation of individual topics and associations when they are modified.
  Developers are free to create their own application-specific validation and
  enforcement routines based on the APIs provided.</p><p>The APIs are described in later chapters. This chapter deals with the
  structure of NPCL and its representation in XML and in a topic map.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2999"></a>Key Concepts</h2></div></div></div><p>This section introduces the key concepts of NPCL.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3004"></a>Types</h3></div></div></div><p>Every topic map consists of a set of topics, occurrences,
      associations and association roles. The Topic Maps model allows all of
      these constructs to be assigned a type. NPCL allows you to specify what
      types are present in your topic map, and what constructs each type can
      be used on. For example, it would allow you to say that the topic
      "Person" can be used as the type of other topics, but not as the type of
      an occurrence or association.</p><p>Types are specified by defining which
      <span class="emphasis"><em>meta-type</em></span> they belong to. The meta-type is simply
      the topic map construct that the type can be applied to. NPCL defines
      the following 4 meta-types:</p><table class="simplelist" border="0" summary="Simple list"><tr><td>Topic Type - types belonging to this meta-type can be used as
        the type of topics in the topic map.</td></tr><tr><td>Occurrence Type - types belonging to this meta-type can be
        used as the type of occurrence in the topic map.</td></tr><tr><td>Association Type - types belonging to this meta-type can be
        used as the type of associations in the topic map.</td></tr><tr><td>Role Type - types belonging to this meta-type can be used as
        the type of association roles in the topic map.</td></tr></table><p>Any type can belong to more than one meta-type. It is allowed, for
      example to say that the topic "Website" is both a Topic Type and an
      Occurrence Type.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3025"></a>Type Facets</h4></div></div></div><p>Some of the meta-types allow type definitions to carry
        additional information in the form of facets. Facets are simply string
        properties with a special pre-defined meaning.</p><p>The following sections describe the facets defined by NPCL and
        how they are used.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3032"></a>Is Abstract Facet</h5></div></div></div><p>This facet is found on Topic Types, Occurrence Types,
          Association Types and Role Types. Its value is a simple boolean
          string (either "true" or "false"). If the value is "true", this
          indicates that the type cannot be instantiated - that is that the
          user should be prevented from creating a topic, occurrence,
          association or role of that type. Although users cannot create
          instances of types marked as abstract, these types can still be used
          in the definition of constraints and these constraint definitions
          are then inherited by subclasses, which may be instantiated by
          users.</p><p>For example we may define an "Employment" association. We want
          to say that the "Employer" role can be played by either a "Person"
          or a "Company". Both "Person" and "Company" derive from a common
          superclass "Legal Entity". We can specify that "Legal Entity" is a
          Topic Type and then use it to define a Role Player Constraint that
          says that topics of type "Legal Entity" can play the role
          "Employer". However to force users to create topics that are either
          instances of "Person" or "Company" and to prevent them from creating
          topics of type "Legal Entity", we can add the Is Abstract facet to
          the type</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3039"></a>Scoping Facet</h5></div></div></div><p>This facet is found on Topic Types. It defines how instances
          of the Topic Type can be used in scoping other constructs in the
          topic map. Topics can be used to define the scope of topic names,
          occurrences or associations. By applying this facet to a Topic Type,
          you can specify that instances of the Topic Type can be used only to
          scope one of these constructs or any combination of them.</p><p>The string value of this facet should be one or more of the
          following strings (separated by spaces, tabs or carriage returns if
          you specify more than one).</p><div class="variablelist"><dl><dt><span class="term">NAME</span></dt><dd><p>Indicates that topics of this type can be used to scope
                topic names.</p></dd><dt><span class="term">OCCURRENCE</span></dt><dd><p>Indicates that topics of this type can be used to scope
                occurrence on topics.</p></dd><dt><span class="term">ASSOCIATION</span></dt><dd><p>Indicates that topics of this type can be used to scope
                associations between topics.</p></dd></dl></div><p>For example, you may create a Topic Type "Language", the
          instances of this Topic Type would be topics such as "English",
          "French", "Klingon" and so on. It makes sense to allow the use of
          these topics to scope names and occurrences, but not much sense to
          allow them to scope associations as associations between topics are
          (almost always) language-independent. To specify this rule in NPCL,
          you simply add a Scoping Facet to the "Language" Topic Type with the
          value "NAME OCCURRENCE" (or "OCCURRENCE NAME" - the ordering is
          irrelevant).</p><p>By default, if no value is provided for the Scoping Facet of a
          Topic Type, it is assumed that instances of the Topic Type should
          not be used for scoping.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3069"></a>Value Datatype Facet</h5></div></div></div><p>This facet is allowed on Occurrence Types. It defines the
          datatype of the value of any occurrence typed by the Occurrence
          Type. A datatype is simply the kind of value that is allowed on the
          occurrence - for example a "Date Of Birth" Occurrence Type might
          only allow values that are of a "date" datatype.</p><p>NPCL does not pre-define a set of datatypes. This is
          deliberate, as different applications and different topic map
          ontologies will have different requirements with regards to
          datatypes. However we recommend that unless you have unusual
          datatyping requirements, you should use the set of URI identifiers
          for datatypes that are defined by <a href="http://www.w3.org/TR/xmlschema-2/" target="_top"> Part 2 of the W3C XML
          Schema specification </a> (as noted in <a href="http://www.w3.org/TR/xmlschema-2/#schema" target="_top"> the schema for XML
          Schema Datatypes</a>, the URI Identifier for a data type is
          simply the URI of the XML Schema namespace, followed by a fragment
          identifier which is the name of the datatype - e.g.
          http://www.w3.org/2001/XMLSchema#int.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3082"></a>Minimum Value and Maximum Value Facets</h5></div></div></div><p>These facets are allowed on Occurrence Types and are used to
          specify the lower and upper bound on the range of acceptable values
          for occurrences typed by the Occurrence Type. For example a "Batting
          Average" Occurrence Type might be given a Minimum Value facet of
          "0.0" and a Maximum Value of "1.0".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3087"></a>Value Pattern Facet</h5></div></div></div><p>The Value Pattern facet is allowed on Occurrence Types and is
          used to specify a regular expression that defines the acceptable
          values for occurrences typed by the Occurrence Type. The regular
          expression should follow the syntax defined in <a href="http://www.w3.org/TR/xmlschema-2/#regexs" target="_top"> Appendix F of Part 2
          of the W3C XML Schema specification </a>.</p><p>For example an occurrence of the Occurrence Type "Price" could
          be restricted to one or more digits followed by a decimal point and
          two further digits by setting the Value Pattern Facet for the
          "Price" Occurrence Type to "(\d)+.\d\d".</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3097"></a>Constraints</h3></div></div></div><p>Constraints in NPCL specify the relationships that are allowed
      between instances of the types defined by the schema. NPCL has three
      kinds of constraints:</p><div class="variablelist"><dl><dt><span class="term">Occurrence Constraints</span></dt><dd><p>Occurrence Constraints are allowed only on Topic Types.
            These constraints specify the types of occurrences that are
            allowed on a topic of a specific Topic Type.</p></dd><dt><span class="term">Role Player Constraints</span></dt><dd><p>Role Player Constraints are allowed only on Topic Types.
            They specify the types of roles in associations that can be played
            by a topic of a specific Topic Type.</p></dd><dt><span class="term">Association Role Constraints</span></dt><dd><p>Association Role Constraints occur only on Association
            Types. They specify the types of roles that can be present in an
            association of a specific Association Type.</p></dd></dl></div><p>All of the constraints support the Minimum Cardinality and Maximum
      Cardinality facets which specify a numeric limit on the number of
      relationships (e.g. the number of occurrences of type "Age" that can
      appear on a topic of type "Person" could be limited to a minimum of 0
      and a maximum of 1). Some constraints provide additional rules about how
      topics can be related to each other. The following sections describe
      each constraint in more detail.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3123"></a>Occurrence Constraints</h4></div></div></div><p>An Occurrence Constraint specifies that a topic of a specific
        Topic Type can have occurrences of a specific Occurrence Type. The
        Minimum Cardinality and Maximum Cardinality facets specify how many
        occurrences of the Occurrence Type are allowed on any single instance
        of the Topic Type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3128"></a>Role Player Constraints</h4></div></div></div><p>A Role Player Constraint specifies that a topic of a specific
        Topic Type can play a role of a specific Role Type. These constraints
        can also optionally limit the roles played to only those in an
        association of a specific Association Type.</p><p>The Minimum and Maximum Cardinality facets constrain how many
        roles of the specified Role Type any instance of the specified Topic
        Type may participate in.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3135"></a>Association Role Constraints</h4></div></div></div><p>An Association Role Constraint specifies that an association of
        a specific Association Type can have a role of a specific Role
        Type.</p><p>The Minimum and Maximum Cardinality facets constraint how many
        roles of the specified Role Type can appear on any single instance of
        the specified Association Type.</p><div class="note"><h3 class="title">Note</h3><p>At this point it might seem confusing that there are limits on
          how many roles a topic can play and how many roles can appear in an
          association. However, the two controls apply in different
          circumstances. Consider a topic map in which we want to record
          people and the companies they work for. We want to record each
          Person-to-Company relationship as a separate association, but we
          recognise that a Company will have many employees and a Person may
          work for more than one company. We create topic types "Person" and
          "Company", association type "Employment" and Role Types "Employee"
          and "Employer". In this example, we would allow the Person Topic
          Type to play 0 or more roles of type "Employee" and the "Company"
          topic type to play 0 or more roles of type "Employer", using the
          Cardinality facets on the Role Player Constraints. However, to
          ensure that we keep each Person-Company relationship in a separate
          associaction, we would restrict the "Employment" Association Type to
          have exactly one role of type "Employer" and exactly one role of
          type "Employee" (set Minimum and Maximum Cardinality to "1").</p></div><p>The Association Role Constraint also supports an additional Arc
        Label Facet. This facet specifies a default human-readable label for
        the role. This label should be the way to describe the association
        relationship when seen from the point of view of the role player. For
        example an association describing the relationship between a person
        and the company they work for might be represented using the
        Association Type "Employment", with Role Types "Employee" and
        "Employer". This implies that there are two Association Role
        Constraints, one between the Association Type "Employment" and the
        Role Type "Employee" and the other between the Association Type
        "Employment" and the Role Type "Employer". For the "Employee" Role
        Type, a suitable arc label might be "Works For" whereas for the
        "Employer" Role Type we might use "Employs".</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3147"></a>Superclass-Subclass Inheritance</h3></div></div></div><p>NPCL provides limited support for inheritance from one type to
      another.</p><p>The rules for constraint inheritance are as follows:</p><div class="orderedlist"><ol type="1"><li><p>A type inherits constraints from all superclasses of the same
          meta-type. A Topic Type inherits only from superclasses which are
          also Topic Types, an Occurrence Type inherits only from Occurrence
          Types and so on.</p><p>It is allowed for a type to have topics of different
          meta-types in its set of superclasses, they are just ignored for the
          purposes of determining inheritance.</p></li><li><p>Only constraints are inherited. Other aspects such as facets
          and extension values (described later) are not inherited.</p><div class="note"><h3 class="title">Note</h3><p>The most important effect of this rule is that datatype,
            Minimum Value, Maximum Value and Value Pattern facets are not
            inherited by Occurrence Types - you must always express these
            facets directly on each subclass type.</p></div></li><li><p>If multiple superclasses define the same constraint, the type
          will inherit a constraint with cardinality facets that satisfy all
          superclass definitions of the constraint. In other words, the
          minimum cardinality will be the highest value defined by any
          superclass, and the maximum cardinality will be the lowest value
          defined by any superclass. If the result is that the maximum
          cardinality drops below the minimum cardinality, this is reported as
          an error.</p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3169"></a>Abstract Types</h4></div></div></div><p>To support the creation of flexible type hierarchies, NPCL
        supports the concept of topics that are not Topic Types, Occurrence
        Types, Role Types or Association Types appearing in the type
        hierarchy. These topics are referred to as "Abstract Types". Abstract
        Types can be useful if you have a large, complex type hierarchy but
        want to limit which types can be created by users. . An abstract type
        is simply a topic that participates in the class hierarchy of an
        ontology, but is not itself one of the specific meta-types.</p><div class="note"><h3 class="title">Note</h3><p>An Abstract Type cannot participate in the definition of any
          constraints and does not have any facets. If you want to use a type
          in the type hierarchy to define a common set of constraints that are
          to be inherited by subclasses, create the type as an instance of one
          of the meta-types and set the Is Abstract Facet on that type to
          "true" to prevent users from creating instances of the type.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3177"></a>Scoping Topics</h3></div></div></div><p>In addition to being able to specify that all instances of a Topic
      Type are allowed to be used in scopes (using the Scoping Facet as
      described above), NPCL allows you to specify that certain specific
      topics can be used in scopes (even if their Topic Type does not allow
      it). This is achieved by adding the special NPCL type "Scoping Topic" to
      the types for the topic(s) that can be used in a scope. In general we
      recommend that you only use this feature for controlled lists of scoping
      topics.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="npcl-schema"></a>NPCL XML Schema</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3185"></a>Overview</h3></div></div></div><p>A set of NPCL constraints can be specified using an XML document
    conforming to the NPCL XML Schema. This representation of the NPCL
    constraints is separate from the representation of the constraints in a
    topic map and so does not simply use the XTM syntax. NPCL XML Schema is
    also a more compact representation of a set of NPCL constraints than the
    topic map representation and is more easily processed using standard XML
    tools such as XSLT. This section describes the NPCL XML Schema in detail.
    The W3C XML Schema representation is also included in the TMCore
    distribution and can be downloaded from <a href="http://www.networkedplanet.com/schemas/npcl/npcl.xsd" target="_top">the
    NetworkedPlanet website</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3193"></a>Namespace</h3></div></div></div><p>The namespace used for NPCL XML Schema is
    http://www.networkedplanet.com/schema/npcl. In the examples in the rest of
    this section, this namespace is assumed to be mapped to the namespace
    prefix "npcl".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3198"></a><code class="sgmltag-element">schema Element</code></h3></div></div></div><p>This is the root element of the NPCL XML synax. It contains a
      single types element which in turn contains the various type definition
      elements.</p><pre class="programlisting">
&lt;npcl:schema&gt;
  &lt;npcl:types&gt;
    &lt;npcl:abstractType ...&gt; ... &lt;/npcl:abstractType&gt;
    &lt;npcl:topicType ... &gt; ... &lt;/npcl:topicType&gt;
    &lt;npcl:occurrenceType ... &gt; ... &lt;/npcl:occurrenceType&gt;
    &lt;npcl:associationType ... &gt; ... &lt;/npcl:associationType&gt;
    &lt;npcl:roleType ... &gt; ... &lt;/npcl:roleType&gt;
    &lt;npcl:scopingTopic ... &gt; ... &lt;/npcl:scopingTopic&gt;
  &lt;/npcl:types&gt;
&lt;/npcl:schema&gt;
</pre><div class="variablelist"><dl><dt><span class="term">npcl:schema</span></dt><dd><p>The root of an NPCL schema definition.</p></dd><dt><span class="term">npcl:schema/npcl:types</span></dt><dd><p>The wrapper for all type definitions contained in the
            schema. This element is OPTIONAL. The children of this element are
            allowed to appear in any order.</p></dd><dt><span class="term">npcl:schema/npcl:types/npcl:abstractType</span></dt><dd><p>An OPTIONAL, REPEATABLE element describing a single Abstract
            Type in the schema.</p></dd><dt><span class="term">npcl:schema/npcl:types/npcl:topicType</span></dt><dd><p>An OPTIONAL, REPEATABLE element describing a single Topic
            Type in the schema.</p></dd><dt><span class="term">npcl:schema/npcl:types/npcl:occurrenceType</span></dt><dd><p>An OPTIONAL, REPEATABLE element describing a single
            Occurrence Type in the schema.</p></dd><dt><span class="term">npcl:schema/npcl:types/npcl:associationType</span></dt><dd><p>An OPTIONAL, REPEATABLE element describing a single
            Assoiation Type in the schema.</p></dd><dt><span class="term">npcl:schema/npcl:types/npcl:roleType</span></dt><dd><p>An OPTIONAL, REPEATABLE element describing a single Role
            Type in the schema.</p></dd><dt><span class="term">npcl:schema/npcl:types/npcl:scopingTopic</span></dt><dd><p>An OPTIONAL, REPEATABLE element describing a single Scoping
            Topic in the schema.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3255"></a><code class="sgmltag-element">abstractType</code> Element</h3></div></div></div><p>This element describes a single Abstract Type in the
      schema.</p><pre class="programlisting">
&lt;npcl:abstractType id="..."&gt;
  &lt;npcl:subjectIdentifier&gt; 
    SUBJECT IDENTIFIER 
  &lt;/npcl:subjectIdentifier&gt;
  &lt;npcl:displayName&gt; NAME &lt;/npcl:displayName&gt;
  &lt;npcl:extension type="EXTENSION TYPE"&gt; 
    EXTENSION VALUE 
  &lt;/npcl:extension&gt;
  &lt;npcl:subclasses&gt; ... &lt;/npcl:subclasses&gt;
&lt;/npcl:abstractType&gt;
</pre><div class="variablelist"><dl><dt><span class="term">npcl:abstractType/@id</span></dt><dd><p>REQUIRED. An internal identifier for the type. This is used
            only for reference purposes inside the NPCL XML document.</p></dd><dt><span class="term">npcl:abstractType/npcl:subjectIdentifier</span></dt><dd><p>REQUIRED, REPEATABLE. Contains a subject identifier URI for
            the type.</p></dd><dt><span class="term">npcl:abstractType/npcl:displayName</span></dt><dd><p>Contains a human-readable display label for the type.</p></dd><dt><span class="term">npcl:abstractType/npcl:extension</span></dt><dd><p>Contains a single typed extension value for the type. The
            value is the string content of this element. The type is specified
            as a URI in the <code class="sgmltag-element">type</code> attribute of this
            elment.</p></dd><dt><span class="term">npcl:abstractType/npcl:subclasses</span></dt><dd><p>Contains a list of the subclasses of this type. This element
            structure is described in detail below.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3298"></a><code class="sgmltag-element">topicType</code></h3></div></div></div><p>This element describes a single Topic Type in the schema. It
      contains the Occurrence and Role Player Constraints that apply to this
      Topic Type.</p><pre class="programlisting">
&lt;npcl:topicType id="..." abstract="true|false"&gt;
  &lt;npcl:subjectIdentifier&gt;
    ...
  &lt;/npcl:subjectIdentifier&gt;
  &lt;npcl:displayName&gt;...&lt;/npcl:displayName&gt;
  &lt;npcl:rolePlayerConstraint 
      roleTypeRef="..." 
      associationTypeRef="..." 
      minCardinality="..." 
      maxCardinality="..."/&gt;
  &lt;npcl:occurrenceConstraint 
      occurrenceTypeRef="..." 
      minCardinality="..." 
      maxCardinality="..."/&gt;
  &lt;npcl:extension type="..."&gt;
    ...
  &lt;/npcl:extension&gt;
  &lt;npcl:subclasses&gt; ... &lt;/npcl:subclasses&gt;
&lt;/topicType&gt;
</pre><div class="variablelist"><dl><dt><span class="term">npcl:topicType/@id</span></dt><dd><p>REQUIRED. An internal identifier for the type. This is used
            only for reference purposes inside the NPCL XML document.</p></dd><dt><span class="term">npcl:topicType/@abstract</span></dt><dd><p>OPTIONAL. A boolean value that indicates if this type is
            abstract. If not specified, this attribute value defaults to
            "false".</p></dd><dt><span class="term">npcl:topicType/npcl:subjectIdentifier</span></dt><dd><p>REQUIRED, REPEATABLE. Contains a subject identifier URI for
            the type.</p></dd><dt><span class="term">npcl:topicType/npcl:displayName</span></dt><dd><p>Contains a human-readable display label for the type.</p></dd><dt><span class="term">npcl:topicType/npcl:rolePlayerConstraint</span></dt><dd><p>This element specifies a single Role Player Constraint that
            applies to this Topic Type.</p><p>The <code class="sgmltag-element">roleTypeRef</code> attribute is REQUIRED and
            contains the internal identifier of the Role Type that is allowed
            by the Role Player Constraint. This must match the value of the id
            attribute on a roleType element in the NPCL XML document.</p><p>The <code class="sgmltag-element">associationTypeRef</code> attribute is
            OPTIONAL and contains the internal identifier of the Association
            Type that is allowed by the Role Player Constraint. This must
            match the value of the id attribute on an associationType element
            in the NPCL XML document. If this attribute is ommitted, then the
            Role Player Constraint applies to all roles of the specified Role
            Type, regardless of the type of association they are in.</p><p>The <code class="sgmltag-element">minCardinality</code> attribute specifies
            the Minimum Cardinality Facet for the constraint. This attribute
            is REQUIRED and its value must be a non-negative integer.</p><p>The <code class="sgmltag-element">maxCardinality</code> attribute specifies
            the Maximum Cardinality Facet for the constraint. This attribute
            is REQUIRED and its value must be either a non-negative integer or
            the string value "unbounded" (indicating that there is no upper
            limit on this constraint.</p></dd><dt><span class="term">npcl:topicType/npcl:occurrenceConstraint</span></dt><dd><p>This element specifies a single Occurrence Cosntraint that
            applies to this Topic Type.</p><p>The <code class="sgmltag-element">occurrenceTypeRef</code> attribute is
            REQUIRED and contains the internal identifier of the Occurrence
            Type that is allowed by the Occurrence Constraint. This must match
            the value of the id attribute on an occurrenceType element in the
            NPCL XML document.</p><p>The <code class="sgmltag-element">minCardinality</code> attribute specifies
            the Minimum Cardinality Facet for the constraint. This attribute
            is REQUIRED and its value must be a non-negative integer.</p><p>The <code class="sgmltag-element">maxCardinality</code> attribute specifies
            the Maximum Cardinality Facet for the constraint. This attribute
            is REQUIRED and its value must be either a non-negative integer or
            the string value "unbounded" (indicating that there is no upper
            limit on this constraint.</p></dd><dt><span class="term">npcl:topicType/npcl:extension</span></dt><dd><p>Contains a single typed extension value for the type. The
            value is the string content of this element. The type is specified
            as a URI in the <code class="sgmltag-element">type</code> attribute of this
            elment.</p></dd><dt><span class="term">npcl:topicType/npcl:subclasses</span></dt><dd><p>Contains a list of the subclasses of this type. This element
            structure is described in detail below.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3393"></a><code class="sgmltag-element">occurrenceType</code> Element</h3></div></div></div><p>This element describes a single Occurrence Type in the schema. It
      contains the Datatype, Minimum Value, Maximum Value and Value Pattern
      Facets that apply to this Occurrence Type.</p><pre class="programlisting">
&lt;npcl:occurrenceType id="..." abstract="true|false"
    datatype="..."
    minValue="..."
    maxValue="..."
    valuePattern="..."&gt;
  &lt;npcl:subjectIdentifier&gt;
    SUBJECT IDENTIFIER
  &lt;/subjectIdentifier&gt;
  &lt;npcl:displayName&gt; NAME &lt;/npcl:displayName&gt;
  &lt;npcl:extension type="..."&gt;
    ...
  &lt;/npcl:extension&gt;
  &lt;npcl:subclasses&gt; ... &lt;/npcl:subclasses&gt;
&lt;/occurrenceType&gt;
	</pre><div class="variablelist"><dl><dt><span class="term">npcl:occurrenceType/@id</span></dt><dd><p>REQUIRED. An internal identifier for the type. This is used
            only for reference purposes inside the NPCL XML document.</p></dd><dt><span class="term">npcl:occurrenceType/@abstract</span></dt><dd><p>OPTIONAL. A boolean value that indicates if this type is
            abstract. If not specified, this attribute value defaults to
            "false".</p></dd><dt><span class="term">npcl:occurrenceType/@datatype</span></dt><dd><p>OPTIONAL. The Datatype Facet value. This attribute specifies
            the datatype for values of occurences of this type.</p></dd><dt><span class="term">npcl:occurrenceType/@minValue</span></dt><dd><p>OPTIONAL. The Minimum Value Facet value. Specifies the
            minimum allowed value for occurrences of this type.</p></dd><dt><span class="term">npcl:occurrenceType/@maxValue</span></dt><dd><p>OPTIONAL. The Maximum Value Facet value. Specifies the
            maximum allowed value for occurrences of this type.</p></dd><dt><span class="term">npcl:occurrenceType/@valuePattern</span></dt><dd><p>OPTIONAL. The Value Pattern Facet value. Specifies a regular
            expressiong that values of occurrences of this type must
            match.</p></dd><dt><span class="term">npcl:occurrenceType/npcl:subjectIdentifier</span></dt><dd><p>REQUIRED, REPEATABLE. Contains a subject identifier URI for
            the type.</p></dd><dt><span class="term">npcl:occurrenceType/npcl:displayName</span></dt><dd><p>Contains a human-readable display label for the type.</p></dd><dt><span class="term">npcl:occurrenceType/npcl:extension</span></dt><dd><p>Contains a single typed extension value for the type. The
            value is the string content of this element. The type is specified
            as a URI in the <code class="sgmltag-element">type</code> attribute of this
            elment.</p></dd><dt><span class="term">npcl:occurrenceType/npcl:subclasses</span></dt><dd><p>Contains a list of the subclasses of this type. This element
            structure is described in detail below.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3466"></a><code class="sgmltag-element">associationType</code> Element</h3></div></div></div><p>This element describes a single Association Type in the schema. It
      contains the Association Role Constraints that apply to this Association
      Type.</p><pre class="programlisting">
&lt;npcl:associationType id="..." abstract="true|false"&gt;
  &lt;npcl:subjectIdentifier&gt;
    ...
  &lt;/npcl:subjectIdentifier&gt;
  &lt;npcl:displayName&gt; ... &lt;/npcl:displayName&gt;
  &lt;associationRoleConstraint 
      roleTypeRef="..." 
      minCardinality="..." 
      maxCardinality="..." 
      arcLabel="..."/&gt;
  &lt;npcl:extension type="..."&gt;
    ...
  &lt;/npcl:extension&gt;
  &lt;npcl:subclasses&gt; ... &lt;/npcl:subclasses&gt;
&lt;/associationType&gt;
      </pre><div class="variablelist"><dl><dt><span class="term">npcl:associationType/@id</span></dt><dd><p>REQUIRED. An internal identifier for the type. This is used
            only for reference purposes inside the NPCL XML document.</p></dd><dt><span class="term">npcl:associationType/@abstract</span></dt><dd><p>OPTIONAL. A boolean value that indicates if this type is
            abstract. If not specified, this attribute value defaults to
            "false".</p></dd><dt><span class="term">npcl:associationType/npcl:subjectIdentifier</span></dt><dd><p>REQUIRED, REPEATABLE. Contains a subject identifier URI for
            the type.</p></dd><dt><span class="term">npcl:associationType/npcl:displayName</span></dt><dd><p>Contains a human-readable display label for the type.</p></dd><dt><span class="term">npcl:associationType/npcl:associationRoleConstraint</span></dt><dd><p>Defines a single Association Role Constraint that applies to
            this Association Type.</p><p>The <code class="sgmltag-element">roleTypeRef</code> attribute is REQUIRED and
            contains the internal identifier of the Role Type that is allowed
            by the Association Role Constraint. This must match the value of
            the id attribute on a roleType element in the NPCL XML
            document.</p><p>The <code class="sgmltag-element">minCardinality</code> attribute specifies
            the Minimum Cardinality Facet for the constraint. This attribute
            is REQUIRED and its value must be a non-negative integer.</p><p>The <code class="sgmltag-element">maxCardinality</code> attribute specifies
            the Maximum Cardinality Facet for the constraint. This attribute
            is REQUIRED and its value must be either a non-negative integer or
            the string value "unbounded" (indicating that there is no upper
            limit on this constraint.</p><p>The <code class="sgmltag-element">arcLabel</code> attribute specifies the Arc
            Label Facet for the constraint. This attribute is OPTIONAL and its
            value should be a human-readable label for the association, when
            displayed in the context of the player of the role identified by
            the <code class="sgmltag-element">roleTypeRef</code> attribute.</p></dd><dt><span class="term">npcl:associationType/npcl:extension</span></dt><dd><p>Contains a single typed extension value for the type. The
            value is the string content of this element. The type is specified
            as a URI in the <code class="sgmltag-element">type</code> attribute of this
            elment.</p></dd><dt><span class="term">npcl:associationType/npcl:subclasses</span></dt><dd><p>Contains a list of the subclasses of this type. This element
            structure is described in detail below.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3544"></a><code class="sgmltag-element">roleType</code> Element</h3></div></div></div><p>This element describes a single Role Type in the schema.</p><pre class="programlisting">
&lt;npcl:roleType id="..." abstract="true|false"&gt;
  &lt;npcl:subjectIdentifier&gt;
    ...
  &lt;/subjectIdentifier&gt;
  &lt;npcl:displayName&gt; ... &lt;/npcl:displayName&gt;
  &lt;npcl:extension type="..."&gt;
    ...
  &lt;/npcl:extension&gt;
  &lt;npcl:subclasses&gt; ... &lt;/npcl:subclasses&gt;
&lt;/roleType&gt;
      </pre><div class="variablelist"><dl><dt><span class="term">npcl:roleType/@id</span></dt><dd><p>REQUIRED. An internal identifier for the type. This is used
            only for reference purposes inside the NPCL XML document.</p></dd><dt><span class="term">npcl:roleType/@abstract</span></dt><dd><p>OPTIONAL. A boolean value that indicates if this type is
            abstract. If not specified, this attribute value defaults to
            "false".</p></dd><dt><span class="term">npcl:roleType/npcl:subjectIdentifier</span></dt><dd><p>REQUIRED, REPEATABLE. Contains a subject identifier URI for
            the type.</p></dd><dt><span class="term">npcl:roleType/npcl:displayName</span></dt><dd><p>REQUIRED. Contains a human-readable display label for the
            type.</p></dd><dt><span class="term">npcl:roleType/npcl:extension</span></dt><dd><p>OPTIONAL, REPEATABLE. Contains a single typed extension
            value for the type. The value is the string content of this
            element. The type is specified as a URI in the
            <code class="sgmltag-element">type</code> attribute of this elment.</p></dd><dt><span class="term">npcl:roleType/npcl:subclasses</span></dt><dd><p>Contains a list of the subclasses of this type. This element
            structure is described in detail below.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3593"></a><code class="sgmltag-element">scopingTopic</code> Element</h3></div></div></div><p>This element describes a single Scoping Topic in the
      schema.</p><pre class="programlisting">
&lt;npcl:scopingTopic&gt;
  &lt;npcl:subjectIdentifier&gt;
    ...
  &lt;/subjectIdentifier&gt;
  &lt;npcl:displayName&gt; ... &lt;/npcl:displayName&gt;
  &lt;npcl:extension type="..."&gt;
    ...
  &lt;/npcl:extension&gt;
&lt;/roleType&gt;
      </pre><div class="variablelist"><dl><dt><span class="term">npcl:scopingTopic/npcl:subjectIdentifier</span></dt><dd><p>REQUIRED, REPEATABLE. Contains a subject identifier URI for
            the type.</p></dd><dt><span class="term">npcl:scopingTopic/npcl:displayName</span></dt><dd><p>REQUIRED. Contains a human-readable display label for the
            type.</p></dd><dt><span class="term">npcl:scopingTopic/npcl:extension</span></dt><dd><p>OPTIONAL, REPEATABLE. Contains a single typed extension
            value for the type. The value is the string content of this
            element. The type is specified as a URI in the
            <code class="sgmltag-element">type</code> attribute of this elment.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3624"></a><code class="sgmltag-element">subclasses</code> Element</h3></div></div></div><p>This element is allowed as a direct child of the abstractType,
      topicType, occurrenceType, associationType and roleType elements. It
      contains a list of all of the subclasses of the type defined by the
      parent element.</p><pre class="programlisting">
&lt;npcl:subclasses&gt;
  &lt;subclass direct="true|false" classRef="..."/&gt;
&lt;/subclasses&gt;
      </pre><div class="variablelist"><dl><dt><span class="term">npcl:subclasses/npcl:subclass</span></dt><dd><p>References a single subclass of the type.</p><p>The <code class="sgmltag-element">direct</code> is OPTIONAL and indicates
            whether the referenced type is a direct subclass of this type or
            if it is an indirect subclass (a subclass of a direct subclass of
            the type). For importing and schema parsing, only direct
            subclasses are considered - indirect subclasses are optionally
            provided when exporting an NPCL schema for processing convenience.
            If omitted, the value defaults to 'true'.</p><p>The <code class="sgmltag-element">classRef</code> attribute is REQUIRED and
            references the type that is a subclass of this type. The value of
            this attribute must be the value of the id attribute of an
            abstractType, topicType, occurrenceType, associationType or
            roleType element in the NPCL XML document.</p></dd></dl></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3651"></a>NPCL Topic Map Ontology</h2></div></div></div><p>A set of NPCL types and constraints can be represented in a topic
    map as a collection of topics, occurrences and associations. This feature
    enables a topic map to carry its own type and constraint information
    without the need to use any external files. It also enables the use of
    generic topic map editing and processing tools to create and update the
    type and constraint information for a topic map. This section describes
    how an NPCL schema can be represented in a topic map.</p><div class="note"><h3 class="title">Note</h3><p>Although we describe the NPCL representation in XML Topic Maps
      (XTM) syntax in this document, it is important to realize that most
      often you will be creating your schemas using either the NPCL XML Schema
      or using tools such as the Topic Map Editor - you will only very rarely need to
      create the XTM structures shown here yourself.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3659"></a>NPCL Meta Types</h3></div></div></div><p>Meta-types are special NPCL-defined topics that are used to
      specify that a topic can be used to type other topics, associations,
      association roles or occurrences in a topic map. This is done by adding
      the meta-type topic as a type to the typing topic. The following
      meta-types are defined by NPCL:</p><div class="table"><a name="d0e3664"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;NPCL Meta Types</b></p><table summary="NPCL Meta Types" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Meta Type</th><th align="center">Relative PSI</th><th align="center">Description</th></tr></thead><tbody><tr><td>Topic Type</td><td><code class="uri">meta-types/topic-type</code></td><td>A topic typed by this meta-type topic can be used as the
              type of other topics in the topic map.</td></tr><tr><td>Association Type</td><td><code class="uri">meta-types/association-type</code></td><td>A topic typed by this meta-type topic can be used to
              specify the type of one or more associations in the topic
              map.</td></tr><tr><td>Association Role Type</td><td><code class="uri">meta-types/role-type</code></td><td>A topic typed by this meta-type topic can be used to
              specify the type of one or more association roles in the topic
              map.</td></tr><tr><td>Occurrence Type</td><td><code class="uri">meta-types/occurrence-type</code></td><td>A topic typed by this meta-type topic can be used as the
              type of one or more occurrences in the topic map.</td></tr><tr><td>Scoping Topic</td><td><code class="uri">types/scoping-topic</code></td><td>A topic typed by this meta-type topic can be used as a
              scoping topic in the scope of an association, occurrence, name
              or variant name in the topic map.</td></tr></tbody></table></div><p>The Relative PSI column shows the PSI for the meta-type relative
      to the base PSI <code class="uri">http://www.networkedplanet.com/psi/npcl/</code>. The
      full PSI must be present as a subject identifier for the meta-type
      topic. For example, to create a "Topic Type" meta-type, you must create
      a topic which has a subject identifier with the URI
      <code class="uri">http://www.networkedplanet.com/psi/npcl/meta-types/topic-type</code>.</p><div class="example"><a name="d0e3725"></a><p class="title"><b>Example&nbsp;11.1.&nbsp;XTM For A Topic Type</b></p><p>The following example shows how a topic type meta-type is
        defined in XTM syntax.</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;
  &lt;!-- 'person' can be used as a topic type --&gt;
  &lt;xtm:topic id="person"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
xlink:href="http://www.networkedplanet.com/psi/npcl/meta-types/topic-type"/&gt;
    &lt;/xtm:instanceOf&gt;
    ...
  &lt;/xtm:topic&gt;
&lt;/xtm:topicMap&gt;</pre><p>Alternatively you could create a full topic for the meta-type
        and reuse it throughout the topic map e.g.</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;!-- Topic type meta-type --&gt;
  &lt;xtm:topic id="topic-type"&gt;
    &lt;xtm:subjectIdentity&gt;
      &lt;xtm:subjectIndicatorRef
xlink:href="http://www.networkedplanet.com/psi/npcl/meta-types/topic-type"/&gt;
    &lt;/xtm:subjectIdentity&gt;
    ...
  &lt;/xtm:topic&gt;

  &lt;xtm:topic id="person"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:topicRef xlink:href="#topic-type"/&gt;
    &lt;/xtm:instanceOf&gt;
  &lt;/xtm:topic&gt;

  &lt;xtm:topic id="company"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:topicRef xlink:href="#topic-type"/&gt;
    &lt;/xtm:instanceOf&gt;
  &lt;/xtm:topic&gt;
&lt;/xtm:topicMap&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3736"></a>Is Abstract Facet</h4></div></div></div><p>The Is Abstract Facet is represented as an occurrence of a
        special NPCL-defined type that can be added to a type topic. The PSI
        for this type is
        http://www.networkedplanet.com/psi/npcl/facets/is-abstract-facet. The
        value of the occurrence should be the string "true" if the type is
        abstract. Any other value for this occurrence will mark the type as
        NOT abstract (i.e. all other values of the occurrence are treated as
        "false").</p><div class="example"><a name="d0e3741"></a><p class="title"><b>Example&nbsp;11.2.&nbsp;An Abstract Topic Type</b></p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;!-- Legal Entity is an abstract Topic Type --&gt;
  &lt;xtm:topic id="legal-entity"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef
xlink:href="http://www.networkedplanet.com/psi/npcl/meta-types/topic-type"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;!-- Is Abstract Facet = true --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef
xlink:href="http://www.networkedplanet.com/psi/npcl/facets/is-abstract-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;true&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;
  &lt;/xtm:topic&gt;

&lt;/xtm:topicMap&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3746"></a>Occurrence Type Value Facets</h4></div></div></div><p>The set of values allowed as resource data in an occurrence of a
        specific type can be defined by adding Value Facets to the occurrence
        type topic. These facets are added as occurrences of special
        NPCL-defined types that can be added to an occurrence type topic. The
        facets are described in the following table.</p><div class="table"><a name="d0e3751"></a><p class="title"><b>Table&nbsp;11.2.&nbsp;Occurrence Type Value Facets</b></p><table summary="Occurrence Type Value Facets" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Facet Name</th><th align="center">Relative PSI</th><th align="center">Description</th></tr></thead><tbody><tr><td>Value Data-Type</td><td>facets/value-datatype-facet</td><td>Specifies the datatype that the occurrence value should
                match. The value of this facet occurrence must be a datatype
                URI. It is strongly recommended to only use the W3C Schema
                data type URIs, but applications may define their own data
                type URIs if needed.</td></tr><tr><td>Minimum Value</td><td>facets/minimum-value-facet</td><td>Specifies the minimum value that occurrence resource
                data must evaluate to. This facet is only consulted if the
                occurrence type also has a Value Data-Type facet and the
                data-type specified is a ranged data type (e.g. integer,
                float, date-time etc. but not string, ID etc.).</td></tr><tr><td>Maximum Value</td><td>facets/maximum-value-facet</td><td>Specifies the minimum value that occurrence resource
                data must evaluate to. This facet is only consulted if the
                occurrence type also has a Value Data-Type facet and the
                data-type specified is a ranged data type.</td></tr><tr><td>Value Pattern</td><td>facets/value-pattern-facet</td><td>Specifies a regular expression pattern that the
                occurrence resource data must match.</td></tr></tbody></table></div><div class="example"><a name="d0e3792"></a><p class="title"><b>Example&nbsp;11.3.&nbsp;Occurrence Type Value Facets In XTM</b></p><p>The following example shows an occurrence type "Age" which is
          restricted to integer values between 0 and 125.</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;xtm:topic id="age"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="htttp://www.networkedplanet.com/psi/npcl/meta-types/occurrence-type"/&gt;
    &lt;xtm:instanceOf&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:baseNameString&gt;Age (in years)&lt;/xtm:baseName&gt;
    &lt;/xtm:baseName&gt;

    &lt;!-- data-type is integer --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef xlink:href="htttp://www.networkedplanet.com/psi/npcl/facets/value-datatype-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;http://www.w3.org/2001/XMLSchema#int&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;

    &lt;!-- minimum value is 0 --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef xlink:href="htttp://www.networkedplanet.com/psi/npcl/facets/minimum-value-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;0&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;

    &lt;!-- maximum value is 125 --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef xlink:href="htttp://www.networkedplanet.com/psi/npcl/facets/maximum-value-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;125&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;
  &lt;/xtm:topic&gt;

&lt;/xtm:topicMap&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3799"></a>Topic Type Scoping Facet</h4></div></div></div><p>The topics of a particular type can be flagged for use in scopes
        using the Scoping Facet on the Topic Type topic. This facet is added
        as an occurrence of a special NPCL-defined type that can be added to a
        Topic Type topic. The PSI for this occurrence type is
        http://www.networkedplanet.com/npcl/facets/scoping-facet.</p><div class="example"><a name="d0e3804"></a><p class="title"><b>Example&nbsp;11.4.&nbsp;Topic Type Scoping Facets In XTM</b></p><p>The following example shows an Topic Type "Language" which is
          restricted to scoping names and occurrence only.</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;xtm:topic id="language"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="htttp://www.networkedplanet.com/psi/npcl/meta-types/topic-type"/&gt;
    &lt;xtm:instanceOf&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:baseNameString&gt;Language&lt;/xtm:baseName&gt;
    &lt;/xtm:baseName&gt;

    &lt;!-- Language topics can scope topic names and occurrences --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef xlink:href="htttp://www.networkedplanet.com/psi/npcl/facets/scoping-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;NAME OCCURRENCE&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;

  &lt;/xtm:topic&gt;

&lt;/xtm:topicMap&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3811"></a>Constraint Topics</h3></div></div></div><p>Constraints in NPCL are always represented as topics. Constraint
      topics are typed using the following NPCL-defined topic types.</p><div class="table"><a name="d0e3816"></a><p class="title"><b>Table&nbsp;11.3.&nbsp;NPCL Constraint Topic Types</b></p><table summary="NPCL Constraint Topic Types" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Constraint Type</th><th align="center">Relative PSI</th><th align="center">Description</th></tr></thead><tbody><tr><td>Occurrence Constraint</td><td><code class="uri">constraints/occurrence-constraint</code></td><td>Constraints of this type define the types of occurrences
              that are allowed on specific types of topic.</td></tr><tr><td>Role Player Constraint</td><td><code class="uri">constraints/role-player-constraint</code></td><td>Constraints of this type define the types of association
              roles that can be played by specific types of topic.</td></tr><tr><td>Association Role Constraint</td><td><code class="uri">constraint/association-role-constraint</code></td><td>Constraints of this type define the types of association
              roles that can be present in associations of a specific
              type.</td></tr></tbody></table></div><div class="note"><h3 class="title">Note</h3><p>Relative PSIs are shown relative to the URI
        <code class="uri">http://www.networkedplanet.com/psi/npcl/</code></p></div><p>Each constraint topic is connected to two or more typing topics
      using associations as described in the sections below.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3860"></a>Constraint Facets</h4></div></div></div><p>Every constraint has two facets. The Minimum Cardinality Facet
        specifies the minimum number of times that the relationship defined by
        the constraint should occur for each instance that it applies to. The
        Maximum Cardinality Facet specifies the maximum number of times that
        the relationship should occur. The table below makes this clearer for
        each constraint type.</p><div class="table"><a name="d0e3865"></a><p class="title"><b>Table&nbsp;11.4.&nbsp;Minimum And Maximum Cardinality Facet Meanings</b></p><table summary="Minimum And Maximum Cardinality Facet Meanings" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Constraint Type</th><th align="center">Minimum / Maximum Cardinality Facet
                Controls</th></tr></thead><tbody><tr><td>Occurrence Constraint</td><td>The number of occurrences of a specific type that
                should occur on each topic of a specific type.</td></tr><tr><td>Role Player Constraint</td><td>The number of times a topic of a specific type can play
                a role of a specific type (optionally specific to one
                association type).</td></tr><tr><td>Association Role Constraint</td><td>The number of times a role of a specific type can
                appear in an association of a specific type.</td></tr></tbody></table></div><p>These facets are specified by adding occurrences to the
        constraint topic. The occurrence type for a Minimum Occurrence Facet
        must have the subject identifier
        <code class="uri">http://www.networkedplanet.com/psi/npcl/facets/minimum-cardinality-facet</code>.
        The occurrence type for a Maximum Occurrence Facet must have the
        subject identifier
        <code class="uri">http://www.networkedplanet.com/psi/npcl/facets/maximum-cardinality-facet</code>.</p><p>The Association Role Constraint also allows an Arc Label Facet
        where the facet value is a name for the association when viewed from
        the context of the role player. This facet value is NOT specified as
        an occurrence in XTM. Instead we use the common Topic Maps convention
        of specifying an arc label for an association using a base name on the
        association type, scoped by the role type. This is shown in the
        following example. To save space, the topics and associations that
        define the Association Role Constraints themselves are not shown (but
        a full example of this is given later in this chapter):</p><div class="example"><a name="d0e3901"></a><p class="title"><b>Example&nbsp;11.5.&nbsp;The Arc Label Facet Expressed in XTM Syntax</b></p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..."&gt;

  &lt;xtm:topic id="employment"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="http://www.networkedplanet.com/psi/npcl/meta-types/association-type" /&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:subjectIdentity&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="http://www.networkedplanet.com/npcl/tests/employment" /&gt;
    &lt;/xtm:subjectIdentity&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:baseNameString&gt;Employment&lt;/xtm:baseNameString&gt;
    &lt;/xtm:baseName&gt;

    &lt;!-- Arc Label for the Employee Association Role --&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:scope&gt;&lt;xtm:topicRef xlink:href="#employee"/&gt;&lt;/xtm:scope&gt;
      &lt;xtm:baseNameString&gt;Works For&lt;/xtm:baseNameString&gt;
    &lt;/xtm:baseName&gt;

    &lt;!-- Arc Label for the Employer Association Role --&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:scope&gt;&lt;xtm:topicRef xlink:href="#employer"/&gt;&lt;/xtm:scope&gt;
      &lt;xtm:baseNameString&gt;Employs&lt;/xtm:baseNameString&gt;
    &lt;/xtm:baseName&gt;
  &lt;/xtm:topic&gt;

  &lt;xtm:topic id="employer"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="http://www.networkedplanet.com/psi/npcl/meta-types/association-role-type" /&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:subjectIdentity&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="http://www.networkedplanet.com/npcl/tests/employer" /&gt;
    &lt;/xtm:subjectIdentity&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:baseNameString&gt;Employer&lt;/xtm:baseNameString&gt;
    &lt;/xtm:baseName&gt;
  &lt;/xtm:topic&gt;

  &lt;xtm:topic id="employee"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="http://www.networkedplanet.com/psi/npcl/meta-types/association-role-type" /&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:subjectIdentity&gt;
      &lt;xtm:subjectIndicatorRef xlink:href="http://www.networkedplanet.com/npcl/tests/employee" /&gt;
    &lt;/xtm:subjectIdentity&gt;
    &lt;xtm:baseName&gt;
      &lt;xtm:baseNameString&gt;Employee&lt;/xtm:baseNameString&gt;
    &lt;/xtm:baseName&gt;
  &lt;/xtm:topic&gt;

&lt;/xtm:topicMap&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3906"></a>Specifying An Occurrence Constraint</h4></div></div></div><p>An Occurrence Constraint represents a restriction on the
        presence of occurrences of a defined type on topics of a defined type.
        Every Occurence Constraint must participate in the following
        associations.</p><div class="table"><a name="d0e3911"></a><p class="title"><b>Table&nbsp;11.5.&nbsp;Associations Required To Specify An Occurrence
          Constraint</b></p><table summary="Associations Required To Specify An Occurrence&#xA;          Constraint" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Association Type (Relative PSI)</th><th align="center">Constraint Role Type (Relative
                PSI)</th><th align="center">Target Role Type (Relative PSI)</th><th align="center">Target Topic Type (Relative PSI)</th></tr></thead><tbody><tr><td>Occurrence Constraint Applies To Topic Type
                (<code class="uri">constraints/oc-applies-to-tt</code>)</td><td>Occurrence Constraint Applies To Topic Type Source Role
                (<code class="uri">constraint/oc-applies-to-tt-source</code>)</td><td>Occurrence Constraint Applies To Topic Type Target Role
                (<code class="uri">constraints/oc-applies-to-tt-target</code>)</td><td>Topic Type (<code class="uri">meta-types/topic-type</code>)</td></tr><tr><td>Occurrence Constraint Allows Occurrence Type
                (<code class="uri">constraints/oc-allows-ot</code>)</td><td>Occurrence Constraint Allows Occurrence Type Source
                Role (<code class="uri">constraints/oc-allows-ot-source</code>)</td><td>Occurrence Constraint Allows Occurrence Type Target
                Role (<code class="uri">constraints/oc-allows-ot-target</code>)</td><td>Occurrence Type
                (<code class="uri">meta-types/occurrence-type</code>)</td></tr></tbody></table></div><div class="example"><a name="d0e3968"></a><p class="title"><b>Example&nbsp;11.6.&nbsp;Example Occurrence Constraint</b></p><p>The following example shows an occurrence constraint that
          specifies that every Person topic has a single, optional Age
          occurrence.</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;!-- Not shown : Definitions of person and age topics. --&gt;

  &lt;!-- Person-Age Occcurrence Constraint --&gt;
  &lt;xtm:topic id="person-age-constraint"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/occurrence-constraint"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;!-- Person must have 0 or 1 Age occurrence --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/facets/minimum-cardinality-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;0&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/facets/maximum-cardinality-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;1&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;
  &lt;/xtm:topic&gt;

  &lt;!-- Person-Age constraint applies to Person topic type --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/oc-applies-to-tt"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/oc-applies-to-tt-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person-age-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/oc-applies-to-tt-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

  &lt;!-- Person-Age constraint constrains occurrences of type Age --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/oc-allows-ot"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/oc-allows-ot-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person-age-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/oc-allows-ot-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#age"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

&lt;/xtm:topicMap&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3975"></a>Specifying A Role Player Constraint</h4></div></div></div><p>A Role Player Constraint represents a relationship between a
        topic type and an association role type that specifies the number of
        times a topic of the topic type can play a role of the association
        role type. A third, optional, element of this constraint is an
        association type. If present, then the constraint applies only to the
        number of times a topic of the topic type can play a role of the
        association role type in an association of the association type. These
        three elements of the constraint are indicated by three separate
        association types as shown in the following table.</p><div class="table"><a name="d0e3980"></a><p class="title"><b>Table&nbsp;11.6.&nbsp;Associations Used To Specify A Role Player Constraint</b></p><table summary="Associations Used To Specify A Role Player Constraint" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Association Type (Relative PSI)</th><th align="center">Constraint Role Type (Relative
                PSI)</th><th align="center">Target Role Type (Relative PSI)</th><th align="center">Target Topic Type (Relative PSI)</th></tr></thead><tbody><tr><td>Role Player Constraint Applies To Topic Type
                (<code class="uri">constraints/rpc-applies-to-tt</code>)</td><td>Role Player Constraint Applies To Topic Type Source
                Role (<code class="uri">constraint/rpc-applies-to-tt-source</code>)</td><td>Role Player Constraint Applies To Topic Type Target
                Role (<code class="uri">constraints/rpc-applies-to-tt-target</code>)</td><td>Topic Type (<code class="uri">meta-types/topic-type</code>)</td></tr><tr><td>Role Player Constraint Allows Role Type
                (<code class="uri">constraints/rpc-allows-rt</code>)</td><td>Role Player Constraint Allows Role Type Source Role
                (<code class="uri">constraints/rpc-allows-rt-source</code>)</td><td>Role Player Constraint Allows Role Type Target Role
                (<code class="uri">constraints/rpc-allows-rt-target</code>)</td><td>Association Role Type
                (<code class="uri">meta-types/association-role-type</code>)</td></tr><tr><td>Role Player Constraint Allows Association Type
                (<code class="uri">constraints/rpc-allows-at</code>)</td><td>Role Player Constraint Allows Association Type Source
                Role (<code class="uri">constraints/rpc-allows-at-source</code>)</td><td>Role Player Constraint Allows Association Type Target
                Role (<code class="uri">constraints/rpc-allows-at-target</code>)</td><td>Association Type
                (<code class="uri">meta-types/association-type</code>)</td></tr></tbody></table></div><div class="example"><a name="d0e4058"></a><p class="title"><b>Example&nbsp;11.7.&nbsp;A Role Player Constraint Specified In XTM</b></p><p>The following example shows a single Role Player Constraint
          that says that a topic of type "person" can play the role of type
          "employee" in an association of type "employment". Note that no
          minimum or maximum cardinality is specified for the constraint. This
          means that the default cardinalities will be applied (0 for minimum
          cardinality and unbounded for maximum cardinality).</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;!-- Not shown: Definitions of person, employee and employment topics --&gt;

  &lt;!-- Person-Employee Role Player Constraint --&gt;
  &lt;xtm:topic id="person-employee-constraint"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/role-player-constraint"/&gt;
    &lt;/xtm:instanceOf&gt;
  &lt;/xtm:topic&gt;

  &lt;!-- Person-Employee constraint applies to Person topic type --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-applies-to-tt"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-applies-to-tt-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person-employee-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-applies-to-tt-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

  &lt;!-- Person-Employee constraint constrains roles of type Employee --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-allows-rt"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-allows-rt-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person-employee-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-allows-rt-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#employee"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

  &lt;!-- Person-Employee constraint constrains roles in associations of type Employment --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-allows-at"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-allows-at-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#person-employee-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/rpc-allows-at-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#employment"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

&lt;/xtm:topicMap&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4065"></a>Specifying An Association Role Constraint</h4></div></div></div><p>An Association Role Constraint specifies a relationship between
        an association type and an association role type that defines how many
        roles of the association role type can appear on an association of the
        association type. To specify an Association Role Constraint, two
        associations are required, one between the constraint topic and the
        association type topic and one between the constraint topic and the
        association role type topic. The table below provides details of the
        associations required.</p><div class="table"><a name="d0e4070"></a><p class="title"><b>Table&nbsp;11.7.&nbsp;Associations Required To Specify An Association Role
          Constraint</b></p><table summary="Associations Required To Specify An Association Role&#xA;          Constraint" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Association Type (Relative PSI)</th><th align="center">Constraint Role Type (Relative
                PSI)</th><th align="center">Target Role Type (Relative PSI)</th><th align="center">Target Topic Type (Relative PSI)</th></tr></thead><tbody><tr><td>Association Role Constraint Applies To Association Type
                (<code class="uri">constraints/arc-applies-to-at</code>)</td><td>Association Role Constraint Applies To Association Type
                Source Role
                (<code class="uri">constraint/arc-applies-to-at-source</code>)</td><td>Association Role Constraint Applies To Association Type
                Target Role
                (<code class="uri">constraints/arc-applies-to-at-target</code>)</td><td>Association Type
                (<code class="uri">meta-types/association-type</code>)</td></tr><tr><td>Association Role Constraint Allows Role Type
                (<code class="uri">constraints/arc-allows-rt</code>)</td><td>Association Role Constraint Allows Role Type Source
                Role (<code class="uri">constraints/arc-allows-rt-source</code>)</td><td>Association Role Constraint Allows Role Type Target
                Role (<code class="uri">constraints/arc-allows-rt-target</code>)</td><td>Association Role Type
                (<code class="uri">meta-types/association-role-type</code>)</td></tr></tbody></table></div><div class="example"><a name="d0e4127"></a><p class="title"><b>Example&nbsp;11.8.&nbsp;An Association Role Constraint in XTM</b></p><p>The following example shows how to specify an Association Role
          Constraint in XTM syntax. The example shows a constraint the
          requires an association of type "employment" to have exactly one
          role of type "employee".</p><pre class="programlisting">&lt;xtm:topicMap xmlns:xtm="..." xmlns:xlink="..."&gt;

  &lt;!-- Not defined : The topics employment and employee. --&gt;

  &lt;!-- Employment-Employee Constraint. --&gt;
  &lt;topic id="employment-employee-constraint"&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/association-role-constraint"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;!-- Employment association must have exactly 1 employee role --&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/facets/minimum-cardinality-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;1&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;
    &lt;xtm:occurrence&gt;
      &lt;xtm:instanceOf&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/facets/maximum-cardinality-facet"/&gt;
      &lt;/xtm:instanceOf&gt;
      &lt;xtm:resourceData&gt;1&lt;/xtm:resourceData&gt;
    &lt;/xtm:occurrence&gt;
  &lt;/topic&gt;

  &lt;!-- Employment-Employee constraint applies to Employment association type --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/arc-applies-to-at"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/arcc-applies-to-at-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#employment-employee-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/arc-applies-to-at-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#employment"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

  &lt;!-- Employment-Employee constraint constrains roles of type employee --&gt;
  &lt;xtm:association&gt;
    &lt;xtm:instanceOf&gt;
      &lt;xtm:subjectIndicatorRef 
           xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/arc-allows-rt"/&gt;
    &lt;/xtm:instanceOf&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/arc-allows-rt-source"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#employment-employee-constraint"/&gt;
    &lt;/xtm:member&gt;
    &lt;xtm:member&gt;
      &lt;xtm:roleSpec&gt;
        &lt;xtm:subjectIndicatorRef 
             xlink:href="http://www.networkedplanet.com/psi/npcl/constraints/arc-allows-rt-target"/&gt;
      &lt;/xtm:roleSpec&gt;
      &lt;xtm:topicRef xlink:href="#employee"/&gt;
    &lt;/xtm:member&gt;
  &lt;/xtm:association&gt;

&lt;/xtm:topicMap&gt;</pre></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="npcl-api"></a>Chapter&nbsp;12.&nbsp;The NPCL Constraints API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e4137">Overview</a></span></dt><dt><span class="section"><a href="#d0e4142">Representation Of The NPCL Model</a></span></dt><dt><span class="section"><a href="#d0e4241">API Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4246">Creating A Schema</a></span></dt><dt><span class="section"><a href="#d0e4275">Retrieving Information From A Schema</a></span></dt><dt><span class="section"><a href="#npcl-api-saving">Saving A Schema</a></span></dt><dt><span class="section"><a href="#d0e4377">Loading A Schema</a></span></dt><dt><span class="section"><a href="#d0e4389">A Dynamic Schema Interface</a></span></dt><dt><span class="section"><a href="#d0e4421">Generating A Schema From A Topic Map</a></span></dt><dt><span class="section"><a href="#d0e4472">Example Code</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4137"></a>Overview</h2></div></div></div><p>All of the functionality of the TMCore implementation of NPCL is
    contained in a single namespace, NetworkedPlanet.Npcl and the entire
    implementation is contained in the assembly NetworkedPlanet.Npcl.dll. The
    HTML Help file for the TMCore API contains a detailed description of every
    public interface, class and method in this namespace. This chapter deals
    with the general principals of the API and gives some short code examples
    of using the API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4142"></a>Representation Of The NPCL Model</h2></div></div></div><p>The NPCL data model is represented by a collection of interfaces as
    shown in the table below.</p><div class="table"><a name="d0e4147"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;Interfaces Representing the NPCL Model</b></p><table summary="Interfaces Representing the NPCL Model" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Interface Name</th><th align="center">Notes</th></tr></thead><tbody><tr><td>ISchema</td><td>Represents an NPCL schema. Contains lists of all of the
            different types contained in the schema and provides index methods
            for finding types and constraints by several different
            criteria.</td></tr><tr><td>ISchemaItem</td><td>The base interface for all types and constraints in a
            schema. Provides methods for retrieving or modifying the extension
            values on a schema item.</td></tr><tr><td>IType</td><td>The base interface for all types in a schema. Derived from
            ISchemaItem, this interface adds support for getting/setting the
            display name and subject identifiers of a type and for
            getting/setting the Is Abstract Facet value.</td></tr><tr><td>IValueType</td><td>The base interface for types that support Value Facets.
            Derived from IType, this interface adds support for
            getting/setting the Datatype, Minimum Value, Maximum Value and
            Value Pattern Facets. Currently only the IOccurrenceType interface
            is dervied from this interface.</td></tr><tr><td>IAbstractType</td><td>Represents an Abstract Type in the schema - a topic that
            participates in the class hierarchy, but is not one of the
            concrete meta-types.</td></tr><tr><td>IAssociationType</td><td>Represents an Association Type in the schema. Derived from
            IType, this interface adds support for getting/creating/removing
            the Association Role Constraints that apply to the Association
            Type.</td></tr><tr><td>IOccurrenceType</td><td>Represents an Occurrence Type in the schema. This interface
            is dervied from the IValueType interface.</td></tr><tr><td>IRoleType</td><td>Represents a Role Type in the schema. This interface is
            dervied from the IType interface.</td></tr><tr><td>ITopicType</td><td>Represents a Topic Type in the schema. Derived from the
            IType interface, this interface adds support for
            getting/creating/removing the Occurence Constraints and Role
            Player Constraints that apply to the Topic Type.</td></tr><tr><td>IScopingTopic</td><td>Represents a Scoping Topic in the schema. This interface is
            derived from IType.</td></tr><tr><td>IConstraint</td><td>The base interface for representation of constraints in the
            schema. This interface is derived from ISchemaItem and adds
            support for getting/setting the Minimum Cardinality and Maximum
            Cardinality Facets.</td></tr><tr><td>IAssociationRoleConstraint</td><td>Represents an Association Role Constraint. Derived from
            IConstraint, this interface adds support for retrieving the
            Association Type and Role Type that participate in the constraint
            and for getting/setting the Arc Label Facet for the
            constraint.</td></tr><tr><td>IOccurrenceConstraint</td><td>Represents an Occurrence Constraint. Derived from
            IConstraint, this interface adds support for retrieving the Topic
            Type and Occurrence Type that participate in the
            constraint.</td></tr><tr><td>IRolePlayerConstraint</td><td>Represents a Role Player Constraint in the schema. This
            interface is dervied from IConstraint and adds support for
            retrieving the Association Type, Role Type and Topic Type that
            participate in the constraint.</td></tr></tbody></table></div><p>To work with the API it is important to understand the containment
    hierarchy of the NPCL model - that is, which items in the model are
    "parents" that contain other items in the model. The containment hierarchy
    is quite simple and is shown in the UML diagram below - the black diamond
    indicates the "container" and the undecorated end indicates the
    "contained" item.</p><div class="figure"><a name="d0e4230"></a><p class="title"><b>Figure&nbsp;12.1.&nbsp;NPCL Containment Hierarchy</b></p><div class="mediaobject"><img src="../graphics/tmcore-api-guide/NpclContainment.png" alt="NPCL Containment Hierarchy"></div></div><p>In addition to the interfaces that represent the schema model, the
    NetworkedPlanet.Npcl namespace provides classes for loading schema
    information from an XML file or from a topic map and for writing schema
    information to an XML file or topic map. In addition several convenience
    methods are provided in the class
    <code class="classname">NetworkedPlanet.Npcl.SchemaUtils</code>. These utility
    classes are described in more detail in the following chapter on using the
    API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4241"></a>API Operations</h2></div></div></div><p>This chapter desribes the principal operations that you can perform
    through the NPCL API.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4246"></a>Creating A Schema</h3></div></div></div><p>The API allows you to create a new schema from scratch. The schema
      model is built in memory and can then be written to an XML file or into
      a topic map stored on a TMCore server using the APIs described in <a href="#npcl-api-saving" title="Saving A Schema">the section called &#8220;Saving A Schema&#8221;</a>.</p><p>To create a new schema, use the static method
      <code class="methodname">CreateSchema()</code> in the
      <code class="methodname">SchemaUtils</code> class. This method returns a new
      instance of the ISchema interface.</p><p>New types and scoping topics can be added to the schema using the
      Create... methods of the ISchema interface. Each Create... method
      requires two identifier strings. The type ID string is an internal
      identifier that will not be used unless the schema is written as an NPCL
      XML file, in which case the ID will be written as the
      <code class="sgmltag-element">id</code> attribute of the NPCL XML element. The subject
      identifier should be a URI identifier for the type. Each unique type
      must have a different subject identifier. It is an error to create two
      types of the same meta-type with the same subject identifier. However,
      it is allowed to create two types of different meta-types with the same
      subject identifier.</p><p>Constraints can be added by using the Create...() method on the
      parent type for the constraint (as shown in the containment hierarchy
      diagram in the previous section). So, to create an Association Role
      Constraint, use the CreateAssociationRoleConstraint() method on the
      IAssociationType instance that the constraint applies to. The Create...
      methods for constraints require you to specify the other types that
      participate in the constraint and the value of the Minimum and Maximum
      Cardinality constraints.</p><p>The code below shows a simple example of creating a schema from
      scratch using the API.</p><div class="example"><a name="d0e4270"></a><p class="title"><b>Example&nbsp;12.1.&nbsp;C# Code To Create An NPCL Schema</b></p><pre class="programlisting">// Every type will use the same base URI for its subject identifier
string psiBase = "http://www.networkedplanet.com/npcl/tests/";

// Get a new blank schema
ISchema schema = SchemaUtils.CreateSchema();

// Person Topic Type
ITopicType person = schema.CreateTopicType("person", psiBase + "person");
person.DisplayName = "Person";

// Company Topic Type
ITopicType company = schema.CreateTopicType("company", psiBase + "company");
company.DisplayName = "Company";

// Employment Association Type
IAssociationType employment = schema.CreateAssociationType("employment", psiBase + "employment");
employment.DisplayName = "Employment";

// Employer Role Type
IRoleType employer = schema.CreateRoleType("employer", psiBase + "employer");
employer.DisplayName = "Employer";

// Employee Role Type
IRoleType employee = schema.CreateRoleType("employee", psiBase + "employee");
employee.DisplayName = "Employee";

// Employment association allows exactly 1 Employer role
employment.CreateAssociationRoleConstraint(employer, 1, 1, "Employs");
// Employment association allows exactly 1 Employee role
employment.CreateAssociationRoleConstraint(employee, 1, 1, "Works For");

// A Person can play the role of Employee 0 or more times
person.CreateRolePlayerConstraint(employee, employment, 0, Cardinality.Unbounded);

// A Company can play the role of Employer 0 or more times
company.CreateRolePlayerConstraint(employer, employment, 0, Cardinality.Unbounded);

// Age Occurrence Type allows integer values between 0 and 120
IOccurrenceType age = schema.CreateOccurrenceType("age", psiBase + "age");
age.DatatypeConstraint = "http://www.w3.org/2001/XMLSchema#int";
age.MinValueConstraint = "0";
age.MaxValueConstraint = "120";

// Person Topic Type can have 0 or 1 Age occurrences
person.CreateOccurrenceConstraint(age, 0, 1);

// Language Topic Type
ITopicType languageTt = schema.CreateTopicType("language", psiBase + "language");
languageTt.DisplayName = "Language";
// Language topics can be used to scope Names or Occurrences (but not Associations)
languageTt.ScopingFacet = Scoping.Name | Scoping.Occurrence;

// Secret Scoping Topic
IScopingTopic secret = schema.CreateScopingTopic("secret", psiBase + "secret");

// Entity Abstract Type
IAbstractType entity = schema.CreateAbstractType("entity", psiBase + "entity");
// Legal Entity Abstract TYpe
IAbstractType legalEntity = schema.CreateAbstractType("legal-entity", psiBase + "legal-entity");

// Create A Class Hierarchy with Entity as the root.
entity.AddDirectSubclass(legalEntity);
legalEntity.AddDirectSubclass(person);
legalEntity.AddDirectSubclass(company);
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4275"></a>Retrieving Information From A Schema</h3></div></div></div><p>The NPCL API provides a small number of functions for retrieving
      type and constraint information from a schema. The key methods are all
      found on the <code class="interfacename">ISchema</code> interface. This
      interface provides properties <span class="property">TopicTypes</span>,
      <span class="property">OccurrenceTypes</span>,
      <span class="property">AssociationTypes</span>, <span class="property">RoleTypes</span>
      and <span class="property">ScopingTopics</span> that return the types and scoping
      topics in the schema. This interface also provides methods named
      <code class="methodname">GetTopicType()</code>,
      <code class="methodname">GetOccurrenceType()</code> etc. that return the type
      with the specified subject identifier. The method
      <code class="methodname">GetSchemaTypes()</code> returns all types with the
      specified subject identifier (as one subject identifier can be used on
      several different types).</p><p>Finally the <code class="interfacename">ISchema</code> interface
      provides three additional lookup methods. The method
      <code class="methodname">GetPlayerTypesForRole(IRoleType,
      IAssociationType)</code> returns all
      <code class="interfacename">ITopicType</code> instances that are allowed to
      play the specified type of role in the specified type of association.
      The method
      <code class="methodname">GetPlayerConstraintsForRole(IRoleType)</code> returns
      all <code class="interfacename">IRolePlayerConstraint</code> instances that
      reference the specified <code class="interfacename">IRoleType</code>. The
      method <code class="methodname">GetAssociationTypesForRole(IRoleType)</code>
      returns all IAssociationTypes that allow a role of the specified type to
      appear.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="npcl-api-saving"></a>Saving A Schema</h3></div></div></div><p>The NPCL API provides two classes for saving a schema. To save a
      schema to an NPCL XML file, use the class
      NetworkedPlanet.Npcl.XmlSchemaWriter. To write a schema to a topic map
      stored in a TMCore server, you can use the class
      NetworkedPlanet.Npcl.TopicMapSchemaWriter.</p><p>The XmlSchemaWriter is simply initialised with the XmlWriter that
      the output is to be written to. Some control over how the schema is
      written is provided by the properties NpclPrefix which sets the prefix
      to be used for the NPCL XML Namspace; and WriteAsFragment which controls
      whether the schema is written as a full XML document or as a fragment
      (with no XML declaration).</p><div class="example"><a name="d0e4337"></a><p class="title"><b>Example&nbsp;12.2.&nbsp;Writing a Schema as XML</b></p><pre class="programlisting">FileInfo outputFile = new FileInfo("myschema.xml");
Stream output = outputFile.Open(FileMode.Create, FileAccess.Write);
XmlTextWriter xmlWriter = new XmlTextWriter(output, System.Text.Encoding.UTF8);
xmlWriter.Formatting = Formatting.Indented;
// Create a new XmlSchemaWriter to write as a full XML document 
// using the prefix "npcl" for the NPCL XML Namespace.
XmlSchemaWriter schemaWriter = new XmlSchemaWriter(xmlWriter, false, "npcl");
schemaWriter.WriteSchema(originalSchema);
// NOTE: The XmlSchemaWriter does not close the XmlWriter at the end of the document.
xmlWriter.Close();</pre></div><p>The <code class="classname">TopicMapSchemaWriter</code> class writes the
      schema information into an <code class="interfacename">ITopicMap</code>
      instance, storing the schema information in the TMCore database as
      topics and associations in the topic map. The
      <code class="classname">TopicMapSchemaWriter</code> can operate in one of three
      different modes.</p><div class="variablelist"><dl><dt><span class="term">ReplaceAll</span></dt><dd><p>In this mode all existing schema information in the topic
            map is removed and replaced by the schema being written.</p></dd><dt><span class="term">ReplaceExisting</span></dt><dd><p>In this mode existing type and constraint information in the
            topic map is overwritten by the input schema, but types and
            constraints not specified in the input schema are left in the
            topic map.</p></dd><dt><span class="term">UpdateExisting</span></dt><dd><p>In this mode existing types and constraints are updated,
            adding any new information contained in the input schema without
            removing existing constraints contained in the topic map.</p></dd></dl></div><div class="example"><a name="d0e4372"></a><p class="title"><b>Example&nbsp;12.3.&nbsp;Writing A Schema Into A Topic Map</b></p><pre class="programlisting">TopicMapSchemaWriter writer = new TopicMapSchemaWriter(tm, SchemaWriterMode.ReplaceAll);
writer.WriteSchema(originalSchema);
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4377"></a>Loading A Schema</h3></div></div></div><p>The NPCL API provides two classes for loading a schema into
      memory. To load a schema from an NPCL XML File, use the class
      NetworkedPlanet.Npcl.XmlSchemaReader. To load a schema from a TMCore
      topic map, use the class NetworkedPlanet.Npcl.TopicMapSchemaReader. Both
      of these classes conform to the common interface ISchemaReader.</p><p>The ISchemaReader interface defines a boolean property, Strict. If
      this property is set to true, then the first error encountered in
      reading schema information will result in an NpclException (or one of
      its derived classes) being thrown. If this property is set to false, the
      reader will attempt to recover from any errors it encounters. If Strict
      is set to false, then after processing, the Errors property of the
      ISchema interface lists all of the NpclExceptions that were caught and
      recovered from during processing.</p><div class="example"><a name="d0e4384"></a><p class="title"><b>Example&nbsp;12.4.&nbsp;Reading A Schema</b></p><pre class="programlisting">ISchemaReader schemaReader = new XmlSchemaReader( new FileStream("simple-ontology.npcl", FileMode.Open) );
// or with an ITopicMap object called myTopicMap:
// ISchemaReader schemaReader = new XmlSchemaReader( myTopicMap );
schemaReader.Strict = false;
ISchema schema = schemaReader.ReadSchema();
foreach(NpclException error in schema.Errors) {
  System.Console.WriteLine(error.Message);
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4389"></a>A Dynamic Schema Interface</h3></div></div></div><p>In addition to providing classes to parse from and write to topic
      maps, the NPCL API also provides an implementation of the
      <code class="interfacename">ISchema</code> interface that is directly
      connected to the database. All type, constraint and property retrievals
      are implemented as database queries and all modifications made to types
      or constraints are committed to the database when they are made. The
      class that provides this implementation is the class
      <code class="classname">NetworkedPlanet.Npcl.TopicMapSchema</code>. The class is
      created by passing in the <code class="interfacename">ITopicMap</code>
      instance that it will work against as the single constructor parameter.
      This class implements the <code class="interfacename">ISchema</code>
      interface and can be used in the same way as an ISchema instance
      returned by the <code class="classname">TopicMapSchemaReader</code> or
      <code class="classname">XmlSchemaReader</code> classes.</p><div class="note"><h3 class="title">Note</h3><p>This implementation is designed for developers who want to
        create their own GUI tools for manipulating schemas stored in a TMCore
        database. You should NOT use this implementation for most applications
        - the <code class="classname">TopicMapSchemaReader</code> is optimised to read
        a schema from a database into memory in large batches and is usually
        more efficient than the <code class="classname">TopicMapSchema</code>
        implementation for applications that need to lookup schema information
        and/or traverse the schema.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4421"></a>Generating A Schema From A Topic Map</h3></div></div></div><p>The NPCL API provides a basic schema inference engine, that can
      examine a topic map to determine what types exist and how they are used.
      The programming interface to this engine is the method
      InferSchema(ITopicMap, string) in the class
      NetworkedPlanet.Npcl.SchemaUtils. To use this method you must pass in
      the ITopicMap handle to the topic map you want to evaluate, and the base
      URI to be used for generated subject identifiers. The base URI string
      you pass in can be null, in which case the base URI defaults to the
      special prefix 'urn:x-tmcore:topicid'.</p><p>The inference proceeds by querying the topic map to determine what
      topics are being used as types; which types of occurrences occur on
      which types of topics; which types of association roles appear in which
      types of associations; and which types of topics play which types of
      association role. The inference also attempts to determine what types of
      topics are being used in scopes and will read and reflect the
      superclass-subclass hierarchy if you have used the XTM-defined subject
      identifiers for the superclass-subclass association type and related
      role types.</p><p>The inference has a number of limitations and failsafes that you
      should be aware of:</p><div class="orderedlist"><ol type="1"><li><p>If a topic is found that is used as a type, NPCL requires that
          the topic must have a subject identifier. If the topic does not
          already have at least one subject identifier, one will be generated
          for it. This generated subject identifier will be base URI prefix
          specified in the method parameters followed by the name of the topic
          forced into lower case. So if you specify the base URI prefix as
          'http://www.mycompany.com/psi/general/', then the topic with the
          name "Sales Forecast" will get the generated subject identifier
          'http://www.mycompany.com/psi/general/sales forecast'.</p><p>If you pass in NULL as the base URI prefix, then topics will
          be assigned a URI of the form 'urn:x-tmcore:topicid:' followed by
          the database object identifier of the topic. This special form of
          URI is recognised by the NPCL TopicMapSchemaWriter class, which will
          find the topic to be updated using its object identifier rather than
          a subject indicator. This feature is provided to allow you to
          generate an NPCL schema from a topic map and then import the schema
          into that topic map without creatin duplicates of topics that did
          not originally have subject identifiers. You should NOT use this
          feature to create an NPCL schema that you then intend to import into
          a different topic map.</p></li><li><p>Cardinality constraints are generated to be rather lax.
          Occurrence and role player constraints are generated as either '0 or
          more' or '1 or more' constraints. A '1 or more' constriant is
          generated only if every topic of the given type would conform to
          that constraint. Association role constraints minimum cardinality is
          generated as 0 or 1 (only if all associations of the given type have
          at least one role that conforms), and maximum cardinality is
          generated as either unbounded or 1 (only if all associations of the
          given type have no more than one role that conforms). You may wish
          to review the generated constraints and make them tighter in certain
          applications.</p></li><li><p>The inference process makes no attempt to infer datatype,
          minimum value, maximum value or value pattern facets for occurrence
          types. You should add these manually if they are required.</p></li><li><p>When a topic is used in a scope, the inference engine works as
          follows:</p><div class="orderedlist"><ol type="a"><li><p>If the scoping topic is also a role type and the scoped
              item is a topic name, the topic is ignored (role types are often
              used to scope association type names to provide
              context-sensitive association labels - these are one-off usages
              and would make the NPCL schema grow unmanageably if they were
              all recorded).</p></li><li><p>If the scoping topic is typed, then the appropriate
              scoping facet value is added to the topic type. So if a topic
              "English" is used to scope a topic name, and the "English" topic
              has the type "Language", then the scoping facet value for the
              type "Language" will include NAME as one of its values.</p></li><li><p>If the scoping topic is untyped, then a new Scoping Topic
              is generated in the schema to represent it. Note, that this
              <span class="emphasis"><em>only</em></span> occurs if the scoping topic is not
              typed.</p></li></ol></div></li></ol></div><div class="example"><a name="d0e4458"></a><p class="title"><b>Example&nbsp;12.5.&nbsp;Generating An NPCL Schema File From A Topic Map</b></p><p>The following code snippet shows how the schema inference engine
        can be used to generate an NPCL file for use in other topic
        maps</p><pre class="programlisting">// Assume that tmSystem is an ITopicMapSystem object that is already initialized

// Get the topic map to process
ITopicMap tm = tmSystem.GetTopicMap("my-topicmap");
// Invoke the SchemaUtils to generate the schema
ISchema schema = SchemaUtils.InferSchema(tm, "http://www.mycompany.com/psi/");
// Write the schema to a file
XmlTextWriter xmlWriter = new XmlTextWriter("my-topicmap.npcl", System.Text.Encoding.UTF8);
xmlWriter.Formatting = Formatting.Indented;
XmlSchemaWriter writer = new XmlSchemaWriter(xmlWriter, false, "npcl");
writer.WriteSchema(schema);
xmlWriter.Close();
</pre></div><div class="example"><a name="d0e4465"></a><p class="title"><b>Example&nbsp;12.6.&nbsp;Generating And Adding Schema Information To A Topic Map</b></p><p>The following code snippet shows how the inference engine can be
        used to populate a topic map with a schema generated from it.</p><pre class="programlisting">// Assume that tmSystem is an ITopicMapSystem object that is already initialized

// Get the topic map to process
ITopicMap tm = tmSystem.GetTopicMap("my-topicmap");

// Invoke the SchemaUtils to generate the schema
// Using null for the subject identifier base generates identifiers
// that will correctly update topics that do not currently have subject identifiers.
ISchema schema = SchemaUtils.InferSchema(tm, null);

// Write the schema back to the topic map - replacing any previous schema information
TopicMapSchemaWriter writer = new TopicMapSchemaWriter(tm, SchemaWriterMode.ReplaceAll);
writer.WriteSchema(schema);</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4472"></a>Example Code</h3></div></div></div><p>Three samples can be found in the <code class="filename">examples</code>
      directory of your TMCore installation. These examples show some of the
      basic operations that are described above.</p><div class="table"><a name="d0e4480"></a><p class="title"><b>Table&nbsp;12.2.&nbsp;NPCL API Examples</b></p><table summary="NPCL API Examples" cellspacing="0" cellpadding="3" border="1"><colgroup><col><col></colgroup><thead><tr><th>Example Directory</th><th>Concepts Demonstrated</th></tr></thead><tbody><tr><td>examples/CS/Npcl/CreateSchema</td><td><p>Programatically creating an NPCL Schema
              Model.</p><p>Writing an NPCL Schema Model out as an NPCL
              XML file.</p></td></tr><tr><td>examples/CS/Npcl/SchemaImporter</td><td><p>Reading an NPCL Schema Model from an NPCL XML
              file.</p><p>Updating schema information in a topic map
              using an NPCL Schema Model.</p></td></tr><tr><td>examples/CS/Npcl/SchemaInfo</td><td><p>Reading an NPCL Schema Model from an NPCL XML
              file.</p><p>Accessing information from an NPCL Schema
              Model programatically.</p></td></tr></tbody></table></div><div class="note"><h3 class="title">Note</h3><p>All of these examples are written in C#. Currently there are no
        Visual Basic equivalent of these examples.</p></div><p>To compile and run an example, open Visual Studio.NET and create a
      new blank solution; then add the .csproj contained in the example
      directory for the example to the solution. The project can then be built
      using the Build &gt; Build Solution menu item. If the solution contains
      multiple projects, set the new example project to be the start-up
      project by right clicking the project in the Solution Explorer pane and
      selecting "Set as StartUp Project" from the pop-up menu.</p><div class="warning"><h3 class="title">Warning</h3><p>The SchemaImporter example requires a connection to a TMCore
        database. The connection string for this is specified in the
        App.config file contained in the example directory. You must ensure
        that this file has the correct connection string before attempting to
        run the example.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4523"></a>CreateSchema Example</h4></div></div></div><p>This example shows how a new NPCL Schema model can be created
        and populated from scratch. This example creates a simple ontology
        consisting of the topic types "Person" and "Company" which are both
        subclasses of "Legal Entity". A Person can have an Age occurrence and
        can play the role "Employee" in an Employment association. Any topic
        of type "Legal Entity" can play the role of "Employer" in an
        Employment association, but this topic type is specified as abstract,
        meaning that end-users would only be allowed to create topics typed by
        one of its subclasses (Person or Company).</p><p>The example also shows how a schema model can be written out as
        an NPCL XML file.</p><p>The example runs as a console application and takes a single
        optional parameter. The parameter specifies the name of the XML file
        that the NPCL schema is to be written to. If the file already exists,
        it will be overwritten. If the parameter is not specified, the NPCL
        schema will be written out to the console.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4532"></a>SchemaImporter Example</h4></div></div></div><p>This example shows how an NPCL Schema model can be read in from
        one storage format (in this case from an NPCL XML file) and written
        out to a different storage format (a topic map in the TMCore
        database). A sample schema file is provided in the example directory
        (the file <code class="filename">simple-ontology.npcl</code>).</p><p>The example runs as a console application and takes a two
        required parameters. The first parameter specifies the name of the XML
        file that the NPCL schema model is to be imported from. The second
        parameter specifies the name of the topic map that the schema
        information is to be written to. If the named topic map does not
        already exist in the database, it will be created. If the topic map
        does already exist, the schema information will be used added to the
        topic map, overwriting any existing schema information for the same
        types (any other types in the topic map will be unaffected).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4542"></a>SchemaInfo Example</h4></div></div></div><p>This example shows how to access an NPCL Schema Model from your
        code. In this case the schema information is read from an NPCL XML
        file.</p><p>The example runs as a console application and takes a single
        required parameter. The parameter specifies the name of the XML file
        that the NPCL schema model is to be imported from. When the
        application runs it first displays a count of the different types
        contained in the schema. You are then prompted to choose if you wish
        to see detailed information. The detailed information lists details on
        each topic type and association type in the schema and finally
        displays a complete class hierarchy for the schema showing all types
        and their subtypes.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4549"></a>Chapter&nbsp;13.&nbsp;Duplicate Removal</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e4552">Introduction</a></span></dt><dt><span class="section"><a href="#d0e4559">What Is Duplicate Information?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4564">Duplicate Information on a Topic</a></span></dt><dt><span class="section"><a href="#d0e4587">Duplicate Information on an Association</a></span></dt><dt><span class="section"><a href="#d0e4596">Duplicate Associations</a></span></dt></dl></dd><dt><span class="section"><a href="#duplicate.removal">Duplicate Removal Procedures</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4552"></a>Introduction</h2></div></div></div><p>
      When programming code or the TMWS web services are used to update a topic map,
      repeated updates can lead to the possibility of duplicate information being
      recorded in a topic map. TMCore provides two database stored procedures
      that clean up this duplicate information, reducing database size and improving
      topic map consistency.
    </p><p>
      This chapter describes what "duplicate information" means in the context
      of a topic map and goes on to describe the stored procedures that can
      be used to remove duplicate information.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4559"></a>What Is Duplicate Information?</h2></div></div></div><p>
      Duplicate information in a topic map falls into one of three categories: duplicate
      information on a topic; duplicate information on an association; and duplicate
      associations.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4564"></a>Duplicate Information on a Topic</h3></div></div></div><p>
	Duplicate information on a topic is found when an topic identifier,
	name, variant name or occurrence repeats exactly the same information
	as another item of the same type <span class="emphasis"><em>on the same topic</em></span>.
	A duplicate name is one that has the same string value and scope
	as another name on the same topic. A duplicate variant name is one
	that has the same string value, scope and parent name as another 
	variant on the same topic. A duplciate occurrence is one with the
	same string value, type and scope as another occurrence on the 
	same topic. A duplicate identifier is a source locator, subject
	identifier or subject locator that has the same value as another
	identifier of the same type on the same topic.
      </p><p>
	How these duplicates are managed varies depending on the type of
	duplicate information.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	    Duplicate names are managed by moving all variant names
	    and source locators
	    from the duplicate name to the name that it duplicates and
	    then removing the duplicate name.
	  </p></li><li><p>Duplicate variant names are managed by moving all
	  source locators from the duplicate variant name to the
	  variant name that it duplicates and then removing the duplicate
	  variant name.</p></li><li><p>Duplicate occurrences are managed by moving all
	  source locators from the duplicate occurrence to the 
	  occurrence that it duplicates and then removing the duplicate
	  occurrence.</p></li><li><p>Duplicate identifiers are managed by simply removing
	  the duplicate identifier.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4587"></a>Duplicate Information on an Association</h3></div></div></div><p>
	With an association, duplicate information is found when a 
	source locator of the association has the same value as 
	another source locator on the same association, or when
	a role in the association has exactly the same role player 
	and role type as another role on the same association.
      </p><p>
	Duplicate source locators are managed by remvoving the duplicate.
      </p><p>
	Duplicate association roles are managed by moving all source
	locators from the duplicate association role to the role that it
	duplicates and then removing the duplicate association role.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4596"></a>Duplicate Associations</h3></div></div></div><p>
	Two associations are consider to be duplicates if they 
	are both in the same topic map, have the same type, scope
	and number of role players and if for each role
	in one of the associations, there is a role in the other 
	association with the same role type and role player.
      </p><p>
	Duplicate associations are managed by moving all source locators
	from the duplicate association to the association that it duplicates
	and then removing the duplicate association.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="duplicate.removal"></a>Duplicate Removal Procedures</h2></div></div></div><p>
      Two stored procedures are provided by TMCore to implement the duplicate
      removal policies described above. These stored procedures can be invoked
      by any member of the tm_writer database role.
    </p><p><b>tm_RemoveDuplicates.&nbsp;</b>This stored procedure is invoked with no parameters and removes
      all duplicate information from all topic maps in the database.</p><p><b>tm_RemoveDuplicatesFromTopicMap.&nbsp;</b>
	This stored procedure takes a topic map OID as its only 
	parameter and removes all duplicate information from the
	topic map identified by that parameter.
      </p><p>
      Either of these duplicate removal stored procedures can be invoked
      either using TSQL in a command-line application such as the SQL Server
      ISQL.EXE application, or using the appropriate database management tool
      such as SQL Server Management Studio for SQL Server 2005. The stored
      procedures can also be invoked directly through code using the TMCore APIs.
      The following is an example of how to invoke the tm_RemoveDuplicates
      procedure from code:
    </p><pre class="programlisting">
      // Assume the tms variable holds an ITopicMapSystem instance
      // Invoking the stored procedure with a command-timeout value of
      // 0 allows for a potentially long-running procedure call.
      tms.ExecuteQuery("EXEC tm_RemoveDuplicates", 0);
    </pre><p>
      Similar code can be used to invoke tm_RemoveDuplicatesFromTopicMap
      to target a specific topic map:
    </p><pre class="programlisting">
      private void RunTopicMapDuplicateSuppression(ITopicMap tm)
      {
        Hashtable parameters = new Hashtable();
        parameters["@tmId"] = tm.ID;
        tm.TopicMapSystem.ExecuteQuery(
	   "EXEC tm_RemoveDuplicatesFromTopicMap @tmId", 
	   parameters, 0);
      }
    </pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="logging"></a>Chapter&nbsp;14.&nbsp;Logging</h2></div></div></div><p>The TMCore assembly makes use of the Apache Log4Net logging library
    to provide configurable runtime logging services. Log4Net provides a
    flexible hierarchical logging system that supports a wide variety of
    logging formats and logging destinations include files, console and the
    system event log. Details on how to Log4Net's features and how to
    configure the Log4Net system can be found on the Apache Log4Net site at
    <a href="http://logging.apache.org/log4net/" target="_top">http://logging.apache.org/log4net/</a>.</p><p>The TMCore assemly does not itself initialise the Log4Net library
    which allows developers creating applications that use TMCore to choose
    their own method of configurable or hardcoded logging
    configuration.</p><div class="note"><h3 class="title">Note</h3><p>The Topic Map Web Service and NPCL Web Service web applications do
      provide a default, overrideable configuration for the Log4Net system -
      see the documentation for those applications for more details.</p></div><p>Log4Net supports the concept of a hierarchical set of logs, so for
    example the log "networkedplanet.tmcore" is a child of the log
    "networkedplanet". Configuration that applies to the parent log also
    applies to the child log unless overridden. This is covered in much more
    detail in the Apache documentation for Log4Net. The TMCore assembly writes
    to the following logs:</p><div class="variablelist"><dl><dt><span class="term">networkedplanet.tmcore.system</span></dt><dd><p>This log receives the following types of messages:</p><div class="itemizedlist"><ul type="disc"><li><p>ERROR messages when a topic map processing exception
              occurs such as an attempt to add a duplicate source
              locator.</p></li><li><p>ERROR messages if the system cannot execute a set of SQL
              statements against the database for some reason.</p></li><li><p>INFO messages when the TMCore
              <code class="interfacename">ITopicMapSystem</code> is initialised
              and closed.</p></li><li><p>DEBUG messages when a query is executed through the
              <code class="methodname">ITopicMapSystem.ExecuteQuery()</code>
              method.</p></li><li><p>DEBUG messages detailing the configuration parameters
              passed when the TopicMapSystem is initialised</p><div class="warning"><h3 class="title">Warning</h3><p>If you are using database authentication with a password
                specified in the connection string, these DEBUG messages will
                contain the user name and password used for the connection in
                clear text. You should either disable DEBUG level logging or
                ensure that logs containing this sensitive data are not
                accessible to unauthorized users.</p></div></li></ul></div></dd><dt><span class="term">networkedplanet.tmcore.merging</span></dt><dd><p>This log only receives DEBUG messages when the system detects
          and performs a merge of two topics.</p></dd><dt><span class="term">networkedplanet.tmcore.syntax.xtm</span></dt><dd><p>Receives INFO and DEBUG level messages as an XTM source is
          parsed into the topic map. The INFO level messages can be used for
          timing imports. The DEBUG level messages are quite verbose and not
          recommended except for debugging purposes.</p></dd><dt><span class="term">networkedplanet.tmcore.util.hierarchy</span></dt><dd><p>This log receives the following types of messages:</p><div class="itemizedlist"><ul type="disc"><li><p>ERROR messages if a required PSI has not been defined in
              the topic map.</p></li><li><p>WARNING messages if a facet is found which cannot be
              processed as a hierarchy for some reason.</p></li><li><p>DEBUG messages as a
              <code class="classname">HierarchyManager</code> instance loads or
              refreshes topic hierarchy data.</p></li></ul></div></dd></dl></div></div></div></body></html>